<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>destination_based_sales.analytical_amne API documentation</title>
<meta name="description" content="This module is used to load and preprocess data from the OECD&#39;s Analytical AMNE database. The latter allows, for non-US
multinational companies, to â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>destination_based_sales.analytical_amne</code></h1>
</header>
<section id="section-intro">
<p>This module is used to load and preprocess data from the OECD's Analytical AMNE database. The latter allows, for non-US
multinational companies, to separate the revenue variables into sales to the host country and sales directed to another
jurisdiction. These are split between sales to the headquarter country and sales to any other country based on BEA data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is used to load and preprocess data from the OECD&#39;s Analytical AMNE database. The latter allows, for non-US
multinational companies, to separate the revenue variables into sales to the host country and sales directed to another
jurisdiction. These are split between sales to the headquarter country and sales to any other country based on BEA data.
&#34;&#34;&#34;


########################################################################################################################
# --- Imports

import os

import numpy as np
import pandas as pd

from destination_based_sales.bea import BEADataPreprocessor
from destination_based_sales.oecd_cbcr import CbCRPreprocessor
from destination_based_sales.utils import compute_foreign_owned_gross_output


########################################################################################################################
# --- Diverse

path_to_dir = os.path.dirname(os.path.abspath(__file__))

path_to_analytical_amne = os.path.join(path_to_dir, &#39;data&#39;, &#39;analytical_amne.xlsx&#39;)
path_to_analytical_amne_domestic = os.path.join(path_to_dir, &#39;data&#39;, &#39;analytical_amne_domesticMNEs.xlsx&#39;)

path_to_geographies = os.path.join(path_to_dir, &#39;data&#39;, &#39;geographies.csv&#39;)


########################################################################################################################
# --- Content

class AnalyticalAMNEPreprocessor:

    def __init__(
        self,
        path_to_analytical_amne=path_to_analytical_amne,
        path_to_analytical_amne_domestic=path_to_analytical_amne_domestic,
        path_to_geographies=path_to_geographies,
        load_OECD_data=True
    ):
        &#34;&#34;&#34;
        The logic used to load and preprocess the OECD&#39;s Analytical AMNE data is encapsulated in a Python class, Analy-
        ticalAMNEPreprocessor. This is the instantiation method of this class, which takes as arguments:

        - the string path to the main Excel file of the Analytical AMNE database, downloaded under the name &#34;analytical_
        amne.xlsx&#34;;

        - the string path to the complementary Excel file, focused on the activities of domestic firms (multinational
        enterprises or purely local companies) and downloaded under the name &#34;analytical_amne_domesticMNEs.xlsx&#34;;

        - the string path to the &#34;geographies.csv&#34;, used to add ISO country codes to the OECD&#39;s data;

        - a boolean, &#34;load_OECD_data&#34;, indicating whether to save the OECD&#39;s aggregated and anonymized country-by-
        country data in a dedicated class attribute.
        &#34;&#34;&#34;
        self.path_to_analytical_amne = path_to_analytical_amne
        self.tab_1 = &#39;GO bilateral&#39;
        self.tab_2 = &#39;GVA EXGR IMGR&#39;

        self.path_to_analytical_amne_domestic = path_to_analytical_amne_domestic
        self.domestic_aamne_tab = &#39;MNE GO GVA EXGR IMGR&#39;

        self.bea_processor = BEADataPreprocessor(year=2016)
        self.bea = self.bea_processor.load_final_data()

        # Depending on the boolean passed as argument, we load the OECD&#39;s CbCR data or not
        if load_OECD_data:
            self.cbcr_preprocessor = CbCRPreprocessor()
            self.oecd = self.cbcr_preprocessor.get_preprocessed_revenue_data()

        else:
            self.oecd = None

        self.path_to_geographies = path_to_geographies

    def load_OECD_CbCR_data(self):
        &#34;&#34;&#34;
        If, when instantiating the AnalyticalAMNEPreprocessor object, the option &#34;load_OECD_data=False&#34; was chosen, this
        method allows to load the OECD&#39;s country-by-country data and to save it in an &#34;oecd&#34; attribute.
        &#34;&#34;&#34;
        self.cbcr_preprocessor = CbCRPreprocessor()
        self.oecd = self.cbcr_preprocessor.get_preprocessed_revenue_data()

    def load_clean_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean the data from the second tab of the &#34;analytical_amne.xlsx&#34; file. This file
        provides information and estimations relative to the activities of foreign-owned and domestically-owned compa-
        nies in a sample of countries, from 2005 to 2016.

        For each country, the dataset indicates the gross value-added, exports and imports of the foreign subsidiaries
        of multinational enterprises (foreign-owned companies) and of locally-owned companies. These variables are fur-
        ther broken down by industry.

        We concentrate on 2016 data to align with country-by-country statistics and only consider the rows corresponding
        to foreign-owned companies. We further sum the three variables over all sectors of activity.
        &#34;&#34;&#34;

        # We read the second tab of the spreadsheet
        aamne = pd.read_excel(
            self.path_to_analytical_amne,
            sheet_name=self.tab_2,
            engine=&#39;openpyxl&#39;
        )

        aamne.drop(
            columns=[&#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;],
            inplace=True
        )

        aamne = aamne[aamne[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR data
        aamne = aamne[aamne[&#39;own&#39;] == &#39;F&#39;].copy()     # And on the activities of foreign-owned companies
        aamne = aamne[aamne[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        aamne.drop(
            columns=[&#39;year&#39;, &#39;own&#39;],
            inplace=True
        )

        aamne.reset_index(drop=True, inplace=True)

        # We consider all sectors of activity and therefore group by countries
        aamne_grouped = aamne.groupby(&#39;cou&#39;).sum().reset_index()

        aamne_grouped.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
                &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
                &#39;exgr&#39;: &#39;EXPORTS&#39;,
                &#39;imgr&#39;: &#39;IMPORTS&#39;
            },
            inplace=True
        )

        return aamne_grouped.copy()

    def load_clean_bilateral_gross_output_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean the data from the first tab of the &#34;analytical_amne.xlsx&#34; file. Indeed, the
        dataset also provides a bilateral mapping of gross output between host countries and the jurisdictions where
        companies are ultimately headquartered.

        Focusing on 2016 data, we sum these results over all sectors of activity and all jurisdictions of ultimate
        ownership, so as to complement the previous dataset with gross output. As explained in more details in the PDF
        report, we also compute the total gross output excluding US-headquartered multinational enterprises.

        This method relies on a function, &#34;compute_foreign_owned_gross_output&#34;, defined in the &#34;utils.py&#34; file.
        &#34;&#34;&#34;

        # We read the first tab of the spreadsheet
        gross_output = pd.read_excel(
            self.path_to_analytical_amne,
            sheet_name=self.tab_1,
            engine=&#39;openpyxl&#39;
        )

        gross_output = gross_output[gross_output[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR
        gross_output = gross_output[gross_output[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        gross_output = gross_output.drop(columns=&#39;year&#39;).groupby(&#39;cou&#39;).sum().reset_index()

        # Relying on a function defined in &#34;utils.py&#34;, we compute for each country the gross output registered there by
        # foreign-owned multinationals, including the US-headquartered ones
        gross_output[&#39;GROSS_OUTPUT_INCL_US&#39;] = gross_output.apply(
            lambda row: compute_foreign_owned_gross_output(row, include_US=True),
            axis=1
        )

        # We do the same, this time excluding US-owned multinational companies
        gross_output[&#39;GROSS_OUTPUT_EXCL_US&#39;] = gross_output.apply(
            lambda row: compute_foreign_owned_gross_output(row, include_US=False),
            axis=1
        )

        # We restrict the dataset to the necessary variables
        gross_output = gross_output[[&#39;cou&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;]].copy()

        gross_output.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;
            },
            inplace=True
        )

        return gross_output.copy()

    def get_merged_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to construct a DataFrame that combines all the relevant information on foreign-owned compa-
        nies, loaded and preprocessed from the &#34;analytical_amne.xlsx&#34; file.
        &#34;&#34;&#34;

        foreign_aamne = self.load_clean_foreign_analytical_amne_data()
        gross_output = self.load_clean_bilateral_gross_output_data()

        foreign_aamne = foreign_aamne.merge(
            gross_output,
            how=&#39;inner&#39;,
            on=&#39;COUNTRY_CODE&#39;
        )

        return foreign_aamne.copy()

    def get_unextended_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        With the three methods defined above, we have obtained, for each in-sample country, information on the gross
        output, gross value-added exports and imports that foreign-owned companies register. We want to deduce an ap-
        proximation of the following three aggregates:

        - sales of foreign-owned companies to the host country;
        - sales of foreign-owned companies to their headquarter country;
        - and sales of foreign-owned companies to any other country.

        The first one is approximated as (gross output - exports).

        The second one is approximated as (exports * ratio of exports to the headquarter country). For each country con-
        sidered, the ratio is assumed to be the same for all foreign-owned companies (simplifying assumption made neces-
        sary because of the limited data at hand) and we therefore draw it from BEA data. If the country is absent from
        BEA data, we take the ratio averaged across all countries in the BEA.

        The third one is simply computed as (exports - sales to the heaquarter country).

        Eventually, as we know that this distribution will be used to split the revenue variables of non-US multinatio-
        nal companies, we exclude the US from these computations. We already have a gross output variable that excludes
        the US and we approximate US exports from the BEA data.
        &#34;&#34;&#34;
        bea = self.bea.copy()

        #-- Average ratios used for countries that do not appear in the BEA data

        # Ratio of exports to total sales, used to deduce non-US exports
        self.imputation_exports_ratio = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum() / bea[&#39;TOTAL&#39;].sum()

        # Ratio of sales to the headquarter country to total sales outside the host country
        self.imputation_exports_to_US_ratio = (
            bea[&#39;TOTAL_US&#39;].sum() / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum()
        )

        #-- Same computation on a per-country basis, used for countries that appear in both Analytical AMNE and BEA data
        bea[&#39;BEA_EXPORTS_RATIO&#39;] = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]) / bea[&#39;TOTAL&#39;]
        bea[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = bea[&#39;TOTAL_US&#39;] / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;])

        # Using the method defined above, we get all the information on the activities of foreign-owned firms
        merged_df = self.get_merged_foreign_analytical_amne_data()

        # Activities in the US and in other countries are treated differently, we separate the two
        us_extract = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] == &#39;USA&#39;].copy()
        merged_df = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] != &#39;USA&#39;].copy()

        # We add the US export and sales-to-headquarter ratios to the main DataFrame
        merged_df = merged_df.merge(
            bea[[&#39;CODE&#39;, &#39;BEA_EXPORTS_RATIO&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;]].copy(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        merged_df.drop(columns=[&#39;CODE&#39;], inplace=True)

        # We replace missing values due to the absence of some countries from BEA data, using the average ratios
        merged_df[&#39;BEA_EXPORTS_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_RATIO&#39;].fillna(self.imputation_exports_ratio)
        merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;].fillna(
            self.imputation_exports_to_US_ratio
        )

        # We compute a proxy for the exports of non-US foreign-owned firms using the BEA export ratios
        merged_df[&#39;EXPORTS_EXCL_US&#39;] = (
            merged_df[&#39;EXPORTS&#39;] - (   # Exports of all foreign-owned firms
                merged_df[&#39;GROSS_OUTPUT_INCL_US&#39;] - merged_df[&#39;GROSS_OUTPUT_EXCL_US&#39;]   # Gross output of US-owned firms
            ) * merged_df[&#39;BEA_EXPORTS_RATIO&#39;]   # Export ratio of US firms
        )

        # We rename columns and filter out the ones that are not relevant anymore
        merged_df.drop(
            columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;BEA_EXPORTS_RATIO&#39;],
            inplace=True
        )

        merged_df.rename(
            columns={
                &#39;GROSS_OUTPUT_EXCL_US&#39;: &#39;TURNOVER&#39;,
                &#39;EXPORTS_EXCL_US&#39;: &#39;EXPORTS&#39;,
            },
            inplace=True
        )

        # We deduce from previous computations the three proxies that we are looking for
        merged_df[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = merged_df[&#39;TURNOVER&#39;] - merged_df[&#39;EXPORTS&#39;]
        merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] * merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;]
        merged_df[&#39;SALES_TO_OTHER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] - merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

        merged_df.drop(
            columns=[&#39;TURNOVER&#39;, &#39;EXPORTS&#39;],
            inplace=True
        )

        # We compute equivalent aggregates for the US
        us_extract[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = us_extract[&#39;GROSS_OUTPUT_INCL_US&#39;] - us_extract[&#39;EXPORTS&#39;]
        us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] * self.imputation_exports_to_US_ratio
        us_extract[&#39;SALES_TO_OTHER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] - us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

        us_extract.drop(
            columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;],
            inplace=True
        )

        # And we concatenate the resulting DataFrames
        merged_df = pd.concat(
            [merged_df, us_extract],
            axis=0
        )

        return merged_df.reset_index(drop=True)

    def get_extended_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        Building upon the previous method, we extend the dataset to all the partner countries that appear in the OECD&#39;s
        aggregated and anonymized country-by-country data. Imputations for countries that are absent from the Analytical
        AMNE database relies on continental aggregates (possible since we are looking for sales ratios and not absolute
        amounts to split the revenue variables.)
        &#34;&#34;&#34;
        if self.oecd is None:
            raise Exception(
                &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
            )

        # We get the unextended dataset
        aamne_foreign = self.get_unextended_foreign_analytical_amne_data()

        geographies = pd.read_csv(self.path_to_geographies)

        # We complement it with continent codes
        aamne_foreign = aamne_foreign.merge(
            geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        # We restrict the CONTINENT_CODE columns to the 4 usual codes
        aamne_foreign.drop(columns=[&#39;CODE&#39;], inplace=True)

        aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
        )

        aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
        )

        #-- Preparing the continental imputations

        # We build the dictionary allowing us to apply the continental imputations
        continent_imputations = {}

        columns_of_interest = [
            &#39;SALES_TO_AFFILIATE_COUNTRY&#39;, &#39;SALES_TO_HEADQUARTER_COUNTRY&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
        ]

        for continent in aamne_foreign[&#39;CONTINENT_CODE&#39;].unique():
            # For each of the 4 unique continent codes, the value is a dictionary
            continent_imputations[continent] = {}

            restricted_df = aamne_foreign[aamne_foreign[&#39;CONTINENT_CODE&#39;] == continent].copy()

            # Total sales registered by foreign-owned companies in this continent
            denominator = restricted_df[columns_of_interest].sum().sum()

            # The dictionary associated with each continent gives the percentage of sales that are associated with each
            # type of destination (host country, headquarter country, any other country)
            for column in columns_of_interest:
                suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
                new_column = &#39;PERC_&#39; + suffix

                numerator = restricted_df[column].sum()

                continent_imputations[continent][new_column] = numerator / denominator

        # We complement the dictionary used for continental imputations
        continent_imputations[&#39;OTHER_GROUPS&#39;] = {
            &#39;PERC_TO_AFFILIATE_COUNTRY&#39;: 0,
            &#39;PERC_TO_HEADQUARTER_COUNTRY&#39;: self.imputation_exports_to_US_ratio,
            &#39;PERC_TO_OTHER_COUNTRY&#39;: 1 - self.imputation_exports_to_US_ratio
        }

        #-- Moving from absolute amounts to sales percentages

        # This will serve as a denominator in the computation of sales percentages
        aamne_foreign[&#39;TOTAL_SALES&#39;] = aamne_foreign[columns_of_interest].sum(axis=1)

        new_columns = []

        # We add three columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix
            new_columns.append(new_column)

            aamne_foreign[new_column] = aamne_foreign[column] / aamne_foreign[&#39;TOTAL_SALES&#39;]

        # We drop the absolute amounts that are not necessary anymore
        aamne_foreign.drop(
            columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
            inplace=True
        )

        #-- Reconstituting the extended DataFrame

        # We start from the list (a DataFrame with continent codes) of unique partner jurisdictions in CbCR data
        partner_jurisdictions = self.oecd[
            [&#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]
        ].drop_duplicates()

        # We add sales percentages from the unextended dataset; missing values are created whenever the affiliate / host
        # country is in CbCR data but not in the Analytical AMNE data
        partner_jurisdictions = partner_jurisdictions.merge(
            aamne_foreign,
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        # We apply the continental imputation for countries that are absent from the Analytical AMNE database
        for new_column in new_columns:
            partner_jurisdictions[new_column] = partner_jurisdictions.apply(
                lambda row: (
                    continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                    if np.isnan(row[new_column]) else row[new_column]
                ),
                axis=1
            )

        partner_jurisdictions.drop(
            columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;],
            inplace=True
        )

        return partner_jurisdictions.copy()

    def load_clean_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean data from the complementary Excel file of the OECD&#39;s Analytical AMNE data-
        base, &#34;analytical_amne_domesticMNEs.xlsx&#34;. It provides information on and estimations of the gross output, gross
        value-added, exports and imports of domestically-owned companies.

        It allows to distinguish between the domestic branches of multinational enterprises and purely local firms.
        Here also, variables are further broken down by industry.

        We concentrate on 2016 data and only consider the rows corresponding to the activities of multinational enter-
        prises. We sum the four variables over all sectors of activity.
        &#34;&#34;&#34;

        # We read the Excel file; paths are defined when instantiating the AnalyticalAMNEPreprocessor object
        aamne_domestic = pd.read_excel(
            self.path_to_analytical_amne_domestic,
            sheet_name=self.domestic_aamne_tab,
            engine=&#39;openpyxl&#39;
        )

        aamne_domestic = aamne_domestic[aamne_domestic[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data
        aamne_domestic = aamne_domestic[aamne_domestic[&#39;own&#39;] == &#39;MNE&#39;].copy()   # And on multinational companies
        aamne_domestic = aamne_domestic[aamne_domestic[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        aamne_domestic.drop(
            columns=[&#39;flag_go&#39;, &#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;, &#39;year&#39;, &#39;own&#39;],
            inplace=True
        )

        # We consider all sectors of activity together and thus group by host country
        aamne_domestic = aamne_domestic.groupby(&#39;cou&#39;).sum().reset_index()

        aamne_domestic.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
                &#39;go&#39;: &#39;GROSS_OUTPUT&#39;,
                &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
                &#39;exgr&#39;: &#39;EXPORTS&#39;,
                &#39;imgr&#39;: &#39;IMPORTS&#39;
            },
            inplace=True
        )

        return aamne_domestic.copy()

    def get_unextended_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        Equivalently to the &#34;get_unextended_foreign_analytical_amne_data&#34; method, this method allows to move from infor-
        mation on gross output, gross value-added, etc. to proxies of sales to the host / headquarter country and sales
        to any other country. Domestic sales are simply defined as (gross output - exports).
        &#34;&#34;&#34;
        aamne_domestic = self.load_clean_domestic_analytical_amne_data()

        aamne_domestic[&#39;DOMESTIC_SALES&#39;] = (
            aamne_domestic[&#39;GROSS_OUTPUT&#39;] - aamne_domestic[&#39;EXPORTS&#39;]
        )
        aamne_domestic[&#39;SALES_TO_OTHER_COUNTRY&#39;] = aamne_domestic[&#39;EXPORTS&#39;].values

        aamne_domestic.drop(
            columns=[&#39;GROSS_OUTPUT&#39;, &#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;],
            inplace=True
        )

        return aamne_domestic.copy()

    def get_extended_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        Building upon the previous method, this method is used (i) to move from sales proxies in absolute amounts to
        sales percentages and (ii) to extend the dataset to the parent countries in CbCR data that are absent from the
        Analytical AMNE database, via continental imputation.
        &#34;&#34;&#34;
        if self.oecd is None:
            raise Exception(
                &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
            )

        # We start from the unextended dataset
        aamne_domestic = self.get_unextended_domestic_analytical_amne_data()

        # We merge it with the geographies DataFrame to add continent codes
        geographies = pd.read_csv(self.path_to_geographies)

        aamne_domestic = aamne_domestic.merge(
            geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        aamne_domestic.drop(columns=[&#39;CODE&#39;], inplace=True)

        # We restrict continent codes to a set of 4 codes
        aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
        )

        aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
        )

        #-- Preparing the continental imputation

        # We build the dictionary allowing us to apply the continental imputations
        continent_imputations = {}

        columns_of_interest = [
            &#39;DOMESTIC_SALES&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
        ]

        for continent in aamne_domestic[&#39;CONTINENT_CODE&#39;].unique():
            # For each of the 4 unique continent codes, the value is a dictionary
            continent_imputations[continent] = {}

            restricted_df = aamne_domestic[aamne_domestic[&#39;CONTINENT_CODE&#39;] == continent].copy()

            # Total sales registered by domestic multinational companies in this continent
            denominator = restricted_df[columns_of_interest].sum().sum()

            for column in columns_of_interest:
                suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
                new_column = &#39;PERC_&#39; + suffix

                numerator = restricted_df[column].sum()

                # The dictionary associated with each continent gives the percentage of sales that are associated with
                # each type of destination (host / headquarter country, any other country)
                continent_imputations[continent][new_column] = numerator / denominator

        #-- Moving from absolute amounts to sales percentages

        # This will serve as a denominator in the computation of sales percentages
        aamne_domestic[&#39;TOTAL_SALES&#39;] = aamne_domestic[columns_of_interest].sum(axis=1)

        new_columns = []

        # We add two columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix
            new_columns.append(new_column)

            aamne_domestic[new_column] = aamne_domestic[column] / aamne_domestic[&#39;TOTAL_SALES&#39;]

        # We drop the absolute amounts that are not necessary anymore
        aamne_domestic.drop(
            columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
            inplace=True
        )

        #-- Reconstituting the extended DataFrame

        # We start from the list (a DataFrame with continent codes) of unique parent jurisdictions in CbCR data
        parent_jurisdictions = self.oecd[
            self.oecd[&#39;PARENT_COUNTRY_CODE&#39;] == self.oecd[&#39;AFFILIATE_COUNTRY_CODE&#39;]
        ][[&#39;PARENT_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates()

        # We add sales percentages from the unextended dataset; missing values are created whenever the parent country
        # is in CbCR data but not in the Analytical AMNE data
        parent_jurisdictions = parent_jurisdictions.merge(
            aamne_domestic,
            how=&#39;left&#39;,
            left_on=&#39;PARENT_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        # We apply the continental imputation for countries that are absent from the Analytical AMNE database
        for new_column in new_columns:
            parent_jurisdictions[new_column] = parent_jurisdictions.apply(
                lambda row: (
                    continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                    if np.isnan(row[new_column]) else row[new_column]
                ),
                axis=1
            )

        parent_jurisdictions.drop(
            columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;],
            inplace=True
        )

        return parent_jurisdictions.copy()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor"><code class="flex name class">
<span>class <span class="ident">AnalyticalAMNEPreprocessor</span></span>
<span>(</span><span>path_to_analytical_amne='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/analytical_amne.xlsx', path_to_analytical_amne_domestic='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/analytical_amne_domesticMNEs.xlsx', path_to_geographies='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/geographies.csv', load_OECD_data=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The logic used to load and preprocess the OECD's Analytical AMNE data is encapsulated in a Python class, Analy-
ticalAMNEPreprocessor. This is the instantiation method of this class, which takes as arguments:</p>
<ul>
<li>
<p>the string path to the main Excel file of the Analytical AMNE database, downloaded under the name "analytical_
amne.xlsx";</p>
</li>
<li>
<p>the string path to the complementary Excel file, focused on the activities of domestic firms (multinational
enterprises or purely local companies) and downloaded under the name "analytical_amne_domesticMNEs.xlsx";</p>
</li>
<li>
<p>the string path to the "geographies.csv", used to add ISO country codes to the OECD's data;</p>
</li>
<li>
<p>a boolean, "load_OECD_data", indicating whether to save the OECD's aggregated and anonymized country-by-
country data in a dedicated class attribute.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalyticalAMNEPreprocessor:

    def __init__(
        self,
        path_to_analytical_amne=path_to_analytical_amne,
        path_to_analytical_amne_domestic=path_to_analytical_amne_domestic,
        path_to_geographies=path_to_geographies,
        load_OECD_data=True
    ):
        &#34;&#34;&#34;
        The logic used to load and preprocess the OECD&#39;s Analytical AMNE data is encapsulated in a Python class, Analy-
        ticalAMNEPreprocessor. This is the instantiation method of this class, which takes as arguments:

        - the string path to the main Excel file of the Analytical AMNE database, downloaded under the name &#34;analytical_
        amne.xlsx&#34;;

        - the string path to the complementary Excel file, focused on the activities of domestic firms (multinational
        enterprises or purely local companies) and downloaded under the name &#34;analytical_amne_domesticMNEs.xlsx&#34;;

        - the string path to the &#34;geographies.csv&#34;, used to add ISO country codes to the OECD&#39;s data;

        - a boolean, &#34;load_OECD_data&#34;, indicating whether to save the OECD&#39;s aggregated and anonymized country-by-
        country data in a dedicated class attribute.
        &#34;&#34;&#34;
        self.path_to_analytical_amne = path_to_analytical_amne
        self.tab_1 = &#39;GO bilateral&#39;
        self.tab_2 = &#39;GVA EXGR IMGR&#39;

        self.path_to_analytical_amne_domestic = path_to_analytical_amne_domestic
        self.domestic_aamne_tab = &#39;MNE GO GVA EXGR IMGR&#39;

        self.bea_processor = BEADataPreprocessor(year=2016)
        self.bea = self.bea_processor.load_final_data()

        # Depending on the boolean passed as argument, we load the OECD&#39;s CbCR data or not
        if load_OECD_data:
            self.cbcr_preprocessor = CbCRPreprocessor()
            self.oecd = self.cbcr_preprocessor.get_preprocessed_revenue_data()

        else:
            self.oecd = None

        self.path_to_geographies = path_to_geographies

    def load_OECD_CbCR_data(self):
        &#34;&#34;&#34;
        If, when instantiating the AnalyticalAMNEPreprocessor object, the option &#34;load_OECD_data=False&#34; was chosen, this
        method allows to load the OECD&#39;s country-by-country data and to save it in an &#34;oecd&#34; attribute.
        &#34;&#34;&#34;
        self.cbcr_preprocessor = CbCRPreprocessor()
        self.oecd = self.cbcr_preprocessor.get_preprocessed_revenue_data()

    def load_clean_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean the data from the second tab of the &#34;analytical_amne.xlsx&#34; file. This file
        provides information and estimations relative to the activities of foreign-owned and domestically-owned compa-
        nies in a sample of countries, from 2005 to 2016.

        For each country, the dataset indicates the gross value-added, exports and imports of the foreign subsidiaries
        of multinational enterprises (foreign-owned companies) and of locally-owned companies. These variables are fur-
        ther broken down by industry.

        We concentrate on 2016 data to align with country-by-country statistics and only consider the rows corresponding
        to foreign-owned companies. We further sum the three variables over all sectors of activity.
        &#34;&#34;&#34;

        # We read the second tab of the spreadsheet
        aamne = pd.read_excel(
            self.path_to_analytical_amne,
            sheet_name=self.tab_2,
            engine=&#39;openpyxl&#39;
        )

        aamne.drop(
            columns=[&#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;],
            inplace=True
        )

        aamne = aamne[aamne[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR data
        aamne = aamne[aamne[&#39;own&#39;] == &#39;F&#39;].copy()     # And on the activities of foreign-owned companies
        aamne = aamne[aamne[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        aamne.drop(
            columns=[&#39;year&#39;, &#39;own&#39;],
            inplace=True
        )

        aamne.reset_index(drop=True, inplace=True)

        # We consider all sectors of activity and therefore group by countries
        aamne_grouped = aamne.groupby(&#39;cou&#39;).sum().reset_index()

        aamne_grouped.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
                &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
                &#39;exgr&#39;: &#39;EXPORTS&#39;,
                &#39;imgr&#39;: &#39;IMPORTS&#39;
            },
            inplace=True
        )

        return aamne_grouped.copy()

    def load_clean_bilateral_gross_output_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean the data from the first tab of the &#34;analytical_amne.xlsx&#34; file. Indeed, the
        dataset also provides a bilateral mapping of gross output between host countries and the jurisdictions where
        companies are ultimately headquartered.

        Focusing on 2016 data, we sum these results over all sectors of activity and all jurisdictions of ultimate
        ownership, so as to complement the previous dataset with gross output. As explained in more details in the PDF
        report, we also compute the total gross output excluding US-headquartered multinational enterprises.

        This method relies on a function, &#34;compute_foreign_owned_gross_output&#34;, defined in the &#34;utils.py&#34; file.
        &#34;&#34;&#34;

        # We read the first tab of the spreadsheet
        gross_output = pd.read_excel(
            self.path_to_analytical_amne,
            sheet_name=self.tab_1,
            engine=&#39;openpyxl&#39;
        )

        gross_output = gross_output[gross_output[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR
        gross_output = gross_output[gross_output[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        gross_output = gross_output.drop(columns=&#39;year&#39;).groupby(&#39;cou&#39;).sum().reset_index()

        # Relying on a function defined in &#34;utils.py&#34;, we compute for each country the gross output registered there by
        # foreign-owned multinationals, including the US-headquartered ones
        gross_output[&#39;GROSS_OUTPUT_INCL_US&#39;] = gross_output.apply(
            lambda row: compute_foreign_owned_gross_output(row, include_US=True),
            axis=1
        )

        # We do the same, this time excluding US-owned multinational companies
        gross_output[&#39;GROSS_OUTPUT_EXCL_US&#39;] = gross_output.apply(
            lambda row: compute_foreign_owned_gross_output(row, include_US=False),
            axis=1
        )

        # We restrict the dataset to the necessary variables
        gross_output = gross_output[[&#39;cou&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;]].copy()

        gross_output.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;
            },
            inplace=True
        )

        return gross_output.copy()

    def get_merged_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to construct a DataFrame that combines all the relevant information on foreign-owned compa-
        nies, loaded and preprocessed from the &#34;analytical_amne.xlsx&#34; file.
        &#34;&#34;&#34;

        foreign_aamne = self.load_clean_foreign_analytical_amne_data()
        gross_output = self.load_clean_bilateral_gross_output_data()

        foreign_aamne = foreign_aamne.merge(
            gross_output,
            how=&#39;inner&#39;,
            on=&#39;COUNTRY_CODE&#39;
        )

        return foreign_aamne.copy()

    def get_unextended_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        With the three methods defined above, we have obtained, for each in-sample country, information on the gross
        output, gross value-added exports and imports that foreign-owned companies register. We want to deduce an ap-
        proximation of the following three aggregates:

        - sales of foreign-owned companies to the host country;
        - sales of foreign-owned companies to their headquarter country;
        - and sales of foreign-owned companies to any other country.

        The first one is approximated as (gross output - exports).

        The second one is approximated as (exports * ratio of exports to the headquarter country). For each country con-
        sidered, the ratio is assumed to be the same for all foreign-owned companies (simplifying assumption made neces-
        sary because of the limited data at hand) and we therefore draw it from BEA data. If the country is absent from
        BEA data, we take the ratio averaged across all countries in the BEA.

        The third one is simply computed as (exports - sales to the heaquarter country).

        Eventually, as we know that this distribution will be used to split the revenue variables of non-US multinatio-
        nal companies, we exclude the US from these computations. We already have a gross output variable that excludes
        the US and we approximate US exports from the BEA data.
        &#34;&#34;&#34;
        bea = self.bea.copy()

        #-- Average ratios used for countries that do not appear in the BEA data

        # Ratio of exports to total sales, used to deduce non-US exports
        self.imputation_exports_ratio = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum() / bea[&#39;TOTAL&#39;].sum()

        # Ratio of sales to the headquarter country to total sales outside the host country
        self.imputation_exports_to_US_ratio = (
            bea[&#39;TOTAL_US&#39;].sum() / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum()
        )

        #-- Same computation on a per-country basis, used for countries that appear in both Analytical AMNE and BEA data
        bea[&#39;BEA_EXPORTS_RATIO&#39;] = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]) / bea[&#39;TOTAL&#39;]
        bea[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = bea[&#39;TOTAL_US&#39;] / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;])

        # Using the method defined above, we get all the information on the activities of foreign-owned firms
        merged_df = self.get_merged_foreign_analytical_amne_data()

        # Activities in the US and in other countries are treated differently, we separate the two
        us_extract = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] == &#39;USA&#39;].copy()
        merged_df = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] != &#39;USA&#39;].copy()

        # We add the US export and sales-to-headquarter ratios to the main DataFrame
        merged_df = merged_df.merge(
            bea[[&#39;CODE&#39;, &#39;BEA_EXPORTS_RATIO&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;]].copy(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        merged_df.drop(columns=[&#39;CODE&#39;], inplace=True)

        # We replace missing values due to the absence of some countries from BEA data, using the average ratios
        merged_df[&#39;BEA_EXPORTS_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_RATIO&#39;].fillna(self.imputation_exports_ratio)
        merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;].fillna(
            self.imputation_exports_to_US_ratio
        )

        # We compute a proxy for the exports of non-US foreign-owned firms using the BEA export ratios
        merged_df[&#39;EXPORTS_EXCL_US&#39;] = (
            merged_df[&#39;EXPORTS&#39;] - (   # Exports of all foreign-owned firms
                merged_df[&#39;GROSS_OUTPUT_INCL_US&#39;] - merged_df[&#39;GROSS_OUTPUT_EXCL_US&#39;]   # Gross output of US-owned firms
            ) * merged_df[&#39;BEA_EXPORTS_RATIO&#39;]   # Export ratio of US firms
        )

        # We rename columns and filter out the ones that are not relevant anymore
        merged_df.drop(
            columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;BEA_EXPORTS_RATIO&#39;],
            inplace=True
        )

        merged_df.rename(
            columns={
                &#39;GROSS_OUTPUT_EXCL_US&#39;: &#39;TURNOVER&#39;,
                &#39;EXPORTS_EXCL_US&#39;: &#39;EXPORTS&#39;,
            },
            inplace=True
        )

        # We deduce from previous computations the three proxies that we are looking for
        merged_df[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = merged_df[&#39;TURNOVER&#39;] - merged_df[&#39;EXPORTS&#39;]
        merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] * merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;]
        merged_df[&#39;SALES_TO_OTHER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] - merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

        merged_df.drop(
            columns=[&#39;TURNOVER&#39;, &#39;EXPORTS&#39;],
            inplace=True
        )

        # We compute equivalent aggregates for the US
        us_extract[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = us_extract[&#39;GROSS_OUTPUT_INCL_US&#39;] - us_extract[&#39;EXPORTS&#39;]
        us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] * self.imputation_exports_to_US_ratio
        us_extract[&#39;SALES_TO_OTHER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] - us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

        us_extract.drop(
            columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;],
            inplace=True
        )

        # And we concatenate the resulting DataFrames
        merged_df = pd.concat(
            [merged_df, us_extract],
            axis=0
        )

        return merged_df.reset_index(drop=True)

    def get_extended_foreign_analytical_amne_data(self):
        &#34;&#34;&#34;
        Building upon the previous method, we extend the dataset to all the partner countries that appear in the OECD&#39;s
        aggregated and anonymized country-by-country data. Imputations for countries that are absent from the Analytical
        AMNE database relies on continental aggregates (possible since we are looking for sales ratios and not absolute
        amounts to split the revenue variables.)
        &#34;&#34;&#34;
        if self.oecd is None:
            raise Exception(
                &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
            )

        # We get the unextended dataset
        aamne_foreign = self.get_unextended_foreign_analytical_amne_data()

        geographies = pd.read_csv(self.path_to_geographies)

        # We complement it with continent codes
        aamne_foreign = aamne_foreign.merge(
            geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        # We restrict the CONTINENT_CODE columns to the 4 usual codes
        aamne_foreign.drop(columns=[&#39;CODE&#39;], inplace=True)

        aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
        )

        aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
        )

        #-- Preparing the continental imputations

        # We build the dictionary allowing us to apply the continental imputations
        continent_imputations = {}

        columns_of_interest = [
            &#39;SALES_TO_AFFILIATE_COUNTRY&#39;, &#39;SALES_TO_HEADQUARTER_COUNTRY&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
        ]

        for continent in aamne_foreign[&#39;CONTINENT_CODE&#39;].unique():
            # For each of the 4 unique continent codes, the value is a dictionary
            continent_imputations[continent] = {}

            restricted_df = aamne_foreign[aamne_foreign[&#39;CONTINENT_CODE&#39;] == continent].copy()

            # Total sales registered by foreign-owned companies in this continent
            denominator = restricted_df[columns_of_interest].sum().sum()

            # The dictionary associated with each continent gives the percentage of sales that are associated with each
            # type of destination (host country, headquarter country, any other country)
            for column in columns_of_interest:
                suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
                new_column = &#39;PERC_&#39; + suffix

                numerator = restricted_df[column].sum()

                continent_imputations[continent][new_column] = numerator / denominator

        # We complement the dictionary used for continental imputations
        continent_imputations[&#39;OTHER_GROUPS&#39;] = {
            &#39;PERC_TO_AFFILIATE_COUNTRY&#39;: 0,
            &#39;PERC_TO_HEADQUARTER_COUNTRY&#39;: self.imputation_exports_to_US_ratio,
            &#39;PERC_TO_OTHER_COUNTRY&#39;: 1 - self.imputation_exports_to_US_ratio
        }

        #-- Moving from absolute amounts to sales percentages

        # This will serve as a denominator in the computation of sales percentages
        aamne_foreign[&#39;TOTAL_SALES&#39;] = aamne_foreign[columns_of_interest].sum(axis=1)

        new_columns = []

        # We add three columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix
            new_columns.append(new_column)

            aamne_foreign[new_column] = aamne_foreign[column] / aamne_foreign[&#39;TOTAL_SALES&#39;]

        # We drop the absolute amounts that are not necessary anymore
        aamne_foreign.drop(
            columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
            inplace=True
        )

        #-- Reconstituting the extended DataFrame

        # We start from the list (a DataFrame with continent codes) of unique partner jurisdictions in CbCR data
        partner_jurisdictions = self.oecd[
            [&#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]
        ].drop_duplicates()

        # We add sales percentages from the unextended dataset; missing values are created whenever the affiliate / host
        # country is in CbCR data but not in the Analytical AMNE data
        partner_jurisdictions = partner_jurisdictions.merge(
            aamne_foreign,
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        # We apply the continental imputation for countries that are absent from the Analytical AMNE database
        for new_column in new_columns:
            partner_jurisdictions[new_column] = partner_jurisdictions.apply(
                lambda row: (
                    continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                    if np.isnan(row[new_column]) else row[new_column]
                ),
                axis=1
            )

        partner_jurisdictions.drop(
            columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;],
            inplace=True
        )

        return partner_jurisdictions.copy()

    def load_clean_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        This method allows to load and clean data from the complementary Excel file of the OECD&#39;s Analytical AMNE data-
        base, &#34;analytical_amne_domesticMNEs.xlsx&#34;. It provides information on and estimations of the gross output, gross
        value-added, exports and imports of domestically-owned companies.

        It allows to distinguish between the domestic branches of multinational enterprises and purely local firms.
        Here also, variables are further broken down by industry.

        We concentrate on 2016 data and only consider the rows corresponding to the activities of multinational enter-
        prises. We sum the four variables over all sectors of activity.
        &#34;&#34;&#34;

        # We read the Excel file; paths are defined when instantiating the AnalyticalAMNEPreprocessor object
        aamne_domestic = pd.read_excel(
            self.path_to_analytical_amne_domestic,
            sheet_name=self.domestic_aamne_tab,
            engine=&#39;openpyxl&#39;
        )

        aamne_domestic = aamne_domestic[aamne_domestic[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data
        aamne_domestic = aamne_domestic[aamne_domestic[&#39;own&#39;] == &#39;MNE&#39;].copy()   # And on multinational companies
        aamne_domestic = aamne_domestic[aamne_domestic[&#39;cou&#39;] != &#39;ROW&#39;].copy()

        aamne_domestic.drop(
            columns=[&#39;flag_go&#39;, &#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;, &#39;year&#39;, &#39;own&#39;],
            inplace=True
        )

        # We consider all sectors of activity together and thus group by host country
        aamne_domestic = aamne_domestic.groupby(&#39;cou&#39;).sum().reset_index()

        aamne_domestic.rename(
            columns={
                &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
                &#39;go&#39;: &#39;GROSS_OUTPUT&#39;,
                &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
                &#39;exgr&#39;: &#39;EXPORTS&#39;,
                &#39;imgr&#39;: &#39;IMPORTS&#39;
            },
            inplace=True
        )

        return aamne_domestic.copy()

    def get_unextended_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        Equivalently to the &#34;get_unextended_foreign_analytical_amne_data&#34; method, this method allows to move from infor-
        mation on gross output, gross value-added, etc. to proxies of sales to the host / headquarter country and sales
        to any other country. Domestic sales are simply defined as (gross output - exports).
        &#34;&#34;&#34;
        aamne_domestic = self.load_clean_domestic_analytical_amne_data()

        aamne_domestic[&#39;DOMESTIC_SALES&#39;] = (
            aamne_domestic[&#39;GROSS_OUTPUT&#39;] - aamne_domestic[&#39;EXPORTS&#39;]
        )
        aamne_domestic[&#39;SALES_TO_OTHER_COUNTRY&#39;] = aamne_domestic[&#39;EXPORTS&#39;].values

        aamne_domestic.drop(
            columns=[&#39;GROSS_OUTPUT&#39;, &#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;],
            inplace=True
        )

        return aamne_domestic.copy()

    def get_extended_domestic_analytical_amne_data(self):
        &#34;&#34;&#34;
        Building upon the previous method, this method is used (i) to move from sales proxies in absolute amounts to
        sales percentages and (ii) to extend the dataset to the parent countries in CbCR data that are absent from the
        Analytical AMNE database, via continental imputation.
        &#34;&#34;&#34;
        if self.oecd is None:
            raise Exception(
                &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
            )

        # We start from the unextended dataset
        aamne_domestic = self.get_unextended_domestic_analytical_amne_data()

        # We merge it with the geographies DataFrame to add continent codes
        geographies = pd.read_csv(self.path_to_geographies)

        aamne_domestic = aamne_domestic.merge(
            geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
            how=&#39;left&#39;,
            left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
        )

        aamne_domestic.drop(columns=[&#39;CODE&#39;], inplace=True)

        # We restrict continent codes to a set of 4 codes
        aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
        )

        aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
            lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
        )

        #-- Preparing the continental imputation

        # We build the dictionary allowing us to apply the continental imputations
        continent_imputations = {}

        columns_of_interest = [
            &#39;DOMESTIC_SALES&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
        ]

        for continent in aamne_domestic[&#39;CONTINENT_CODE&#39;].unique():
            # For each of the 4 unique continent codes, the value is a dictionary
            continent_imputations[continent] = {}

            restricted_df = aamne_domestic[aamne_domestic[&#39;CONTINENT_CODE&#39;] == continent].copy()

            # Total sales registered by domestic multinational companies in this continent
            denominator = restricted_df[columns_of_interest].sum().sum()

            for column in columns_of_interest:
                suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
                new_column = &#39;PERC_&#39; + suffix

                numerator = restricted_df[column].sum()

                # The dictionary associated with each continent gives the percentage of sales that are associated with
                # each type of destination (host / headquarter country, any other country)
                continent_imputations[continent][new_column] = numerator / denominator

        #-- Moving from absolute amounts to sales percentages

        # This will serve as a denominator in the computation of sales percentages
        aamne_domestic[&#39;TOTAL_SALES&#39;] = aamne_domestic[columns_of_interest].sum(axis=1)

        new_columns = []

        # We add two columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix
            new_columns.append(new_column)

            aamne_domestic[new_column] = aamne_domestic[column] / aamne_domestic[&#39;TOTAL_SALES&#39;]

        # We drop the absolute amounts that are not necessary anymore
        aamne_domestic.drop(
            columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
            inplace=True
        )

        #-- Reconstituting the extended DataFrame

        # We start from the list (a DataFrame with continent codes) of unique parent jurisdictions in CbCR data
        parent_jurisdictions = self.oecd[
            self.oecd[&#39;PARENT_COUNTRY_CODE&#39;] == self.oecd[&#39;AFFILIATE_COUNTRY_CODE&#39;]
        ][[&#39;PARENT_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates()

        # We add sales percentages from the unextended dataset; missing values are created whenever the parent country
        # is in CbCR data but not in the Analytical AMNE data
        parent_jurisdictions = parent_jurisdictions.merge(
            aamne_domestic,
            how=&#39;left&#39;,
            left_on=&#39;PARENT_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        # We apply the continental imputation for countries that are absent from the Analytical AMNE database
        for new_column in new_columns:
            parent_jurisdictions[new_column] = parent_jurisdictions.apply(
                lambda row: (
                    continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                    if np.isnan(row[new_column]) else row[new_column]
                ),
                axis=1
            )

        parent_jurisdictions.drop(
            columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;],
            inplace=True
        )

        return parent_jurisdictions.copy()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_domestic_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">get_extended_domestic_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Building upon the previous method, this method is used (i) to move from sales proxies in absolute amounts to
sales percentages and (ii) to extend the dataset to the parent countries in CbCR data that are absent from the
Analytical AMNE database, via continental imputation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extended_domestic_analytical_amne_data(self):
    &#34;&#34;&#34;
    Building upon the previous method, this method is used (i) to move from sales proxies in absolute amounts to
    sales percentages and (ii) to extend the dataset to the parent countries in CbCR data that are absent from the
    Analytical AMNE database, via continental imputation.
    &#34;&#34;&#34;
    if self.oecd is None:
        raise Exception(
            &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
        )

    # We start from the unextended dataset
    aamne_domestic = self.get_unextended_domestic_analytical_amne_data()

    # We merge it with the geographies DataFrame to add continent codes
    geographies = pd.read_csv(self.path_to_geographies)

    aamne_domestic = aamne_domestic.merge(
        geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
        how=&#39;left&#39;,
        left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
    )

    aamne_domestic.drop(columns=[&#39;CODE&#39;], inplace=True)

    # We restrict continent codes to a set of 4 codes
    aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
        lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
    )

    aamne_domestic[&#39;CONTINENT_CODE&#39;] = aamne_domestic[&#39;CONTINENT_CODE&#39;].map(
        lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
    )

    #-- Preparing the continental imputation

    # We build the dictionary allowing us to apply the continental imputations
    continent_imputations = {}

    columns_of_interest = [
        &#39;DOMESTIC_SALES&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
    ]

    for continent in aamne_domestic[&#39;CONTINENT_CODE&#39;].unique():
        # For each of the 4 unique continent codes, the value is a dictionary
        continent_imputations[continent] = {}

        restricted_df = aamne_domestic[aamne_domestic[&#39;CONTINENT_CODE&#39;] == continent].copy()

        # Total sales registered by domestic multinational companies in this continent
        denominator = restricted_df[columns_of_interest].sum().sum()

        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix

            numerator = restricted_df[column].sum()

            # The dictionary associated with each continent gives the percentage of sales that are associated with
            # each type of destination (host / headquarter country, any other country)
            continent_imputations[continent][new_column] = numerator / denominator

    #-- Moving from absolute amounts to sales percentages

    # This will serve as a denominator in the computation of sales percentages
    aamne_domestic[&#39;TOTAL_SALES&#39;] = aamne_domestic[columns_of_interest].sum(axis=1)

    new_columns = []

    # We add two columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
    for column in columns_of_interest:
        suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
        new_column = &#39;PERC_&#39; + suffix
        new_columns.append(new_column)

        aamne_domestic[new_column] = aamne_domestic[column] / aamne_domestic[&#39;TOTAL_SALES&#39;]

    # We drop the absolute amounts that are not necessary anymore
    aamne_domestic.drop(
        columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
        inplace=True
    )

    #-- Reconstituting the extended DataFrame

    # We start from the list (a DataFrame with continent codes) of unique parent jurisdictions in CbCR data
    parent_jurisdictions = self.oecd[
        self.oecd[&#39;PARENT_COUNTRY_CODE&#39;] == self.oecd[&#39;AFFILIATE_COUNTRY_CODE&#39;]
    ][[&#39;PARENT_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates()

    # We add sales percentages from the unextended dataset; missing values are created whenever the parent country
    # is in CbCR data but not in the Analytical AMNE data
    parent_jurisdictions = parent_jurisdictions.merge(
        aamne_domestic,
        how=&#39;left&#39;,
        left_on=&#39;PARENT_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
    )

    # We apply the continental imputation for countries that are absent from the Analytical AMNE database
    for new_column in new_columns:
        parent_jurisdictions[new_column] = parent_jurisdictions.apply(
            lambda row: (
                continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                if np.isnan(row[new_column]) else row[new_column]
            ),
            axis=1
        )

    parent_jurisdictions.drop(
        columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;],
        inplace=True
    )

    return parent_jurisdictions.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_foreign_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">get_extended_foreign_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Building upon the previous method, we extend the dataset to all the partner countries that appear in the OECD's
aggregated and anonymized country-by-country data. Imputations for countries that are absent from the Analytical
AMNE database relies on continental aggregates (possible since we are looking for sales ratios and not absolute
amounts to split the revenue variables.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extended_foreign_analytical_amne_data(self):
    &#34;&#34;&#34;
    Building upon the previous method, we extend the dataset to all the partner countries that appear in the OECD&#39;s
    aggregated and anonymized country-by-country data. Imputations for countries that are absent from the Analytical
    AMNE database relies on continental aggregates (possible since we are looking for sales ratios and not absolute
    amounts to split the revenue variables.)
    &#34;&#34;&#34;
    if self.oecd is None:
        raise Exception(
            &#34;Before you may use this method, you have to load the OECD&#39;s CbCR data with the dedicated method.&#34;
        )

    # We get the unextended dataset
    aamne_foreign = self.get_unextended_foreign_analytical_amne_data()

    geographies = pd.read_csv(self.path_to_geographies)

    # We complement it with continent codes
    aamne_foreign = aamne_foreign.merge(
        geographies[[&#39;CODE&#39;, &#39;CONTINENT_CODE&#39;]].drop_duplicates(),
        how=&#39;left&#39;,
        left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
    )

    # We restrict the CONTINENT_CODE columns to the 4 usual codes
    aamne_foreign.drop(columns=[&#39;CODE&#39;], inplace=True)

    aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
        lambda x: &#39;APAC&#39; if x in [&#39;ASIA&#39;, &#39;OCN&#39;] or x is None else x
    )

    aamne_foreign[&#39;CONTINENT_CODE&#39;] = aamne_foreign[&#39;CONTINENT_CODE&#39;].map(
        lambda x: &#39;AMR&#39; if x in [&#39;SAMR&#39;, &#39;NAMR&#39;] else x
    )

    #-- Preparing the continental imputations

    # We build the dictionary allowing us to apply the continental imputations
    continent_imputations = {}

    columns_of_interest = [
        &#39;SALES_TO_AFFILIATE_COUNTRY&#39;, &#39;SALES_TO_HEADQUARTER_COUNTRY&#39;, &#39;SALES_TO_OTHER_COUNTRY&#39;
    ]

    for continent in aamne_foreign[&#39;CONTINENT_CODE&#39;].unique():
        # For each of the 4 unique continent codes, the value is a dictionary
        continent_imputations[continent] = {}

        restricted_df = aamne_foreign[aamne_foreign[&#39;CONTINENT_CODE&#39;] == continent].copy()

        # Total sales registered by foreign-owned companies in this continent
        denominator = restricted_df[columns_of_interest].sum().sum()

        # The dictionary associated with each continent gives the percentage of sales that are associated with each
        # type of destination (host country, headquarter country, any other country)
        for column in columns_of_interest:
            suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
            new_column = &#39;PERC_&#39; + suffix

            numerator = restricted_df[column].sum()

            continent_imputations[continent][new_column] = numerator / denominator

    # We complement the dictionary used for continental imputations
    continent_imputations[&#39;OTHER_GROUPS&#39;] = {
        &#39;PERC_TO_AFFILIATE_COUNTRY&#39;: 0,
        &#39;PERC_TO_HEADQUARTER_COUNTRY&#39;: self.imputation_exports_to_US_ratio,
        &#39;PERC_TO_OTHER_COUNTRY&#39;: 1 - self.imputation_exports_to_US_ratio
    }

    #-- Moving from absolute amounts to sales percentages

    # This will serve as a denominator in the computation of sales percentages
    aamne_foreign[&#39;TOTAL_SALES&#39;] = aamne_foreign[columns_of_interest].sum(axis=1)

    new_columns = []

    # We add three columns to the DataFrame that correspond to sales percentages instead of the absolute amounts
    for column in columns_of_interest:
        suffix = column.replace(&#39;SALES_&#39;, &#39;&#39;)
        new_column = &#39;PERC_&#39; + suffix
        new_columns.append(new_column)

        aamne_foreign[new_column] = aamne_foreign[column] / aamne_foreign[&#39;TOTAL_SALES&#39;]

    # We drop the absolute amounts that are not necessary anymore
    aamne_foreign.drop(
        columns=columns_of_interest + [&#39;TOTAL_SALES&#39;, &#39;CONTINENT_CODE&#39;],
        inplace=True
    )

    #-- Reconstituting the extended DataFrame

    # We start from the list (a DataFrame with continent codes) of unique partner jurisdictions in CbCR data
    partner_jurisdictions = self.oecd[
        [&#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;CONTINENT_CODE&#39;]
    ].drop_duplicates()

    # We add sales percentages from the unextended dataset; missing values are created whenever the affiliate / host
    # country is in CbCR data but not in the Analytical AMNE data
    partner_jurisdictions = partner_jurisdictions.merge(
        aamne_foreign,
        how=&#39;left&#39;,
        left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
    )

    # We apply the continental imputation for countries that are absent from the Analytical AMNE database
    for new_column in new_columns:
        partner_jurisdictions[new_column] = partner_jurisdictions.apply(
            lambda row: (
                continent_imputations[row[&#39;CONTINENT_CODE&#39;]][new_column]
                if np.isnan(row[new_column]) else row[new_column]
            ),
            axis=1
        )

    partner_jurisdictions.drop(
        columns=[&#39;CONTINENT_CODE&#39;, &#39;COUNTRY_CODE&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;],
        inplace=True
    )

    return partner_jurisdictions.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_merged_foreign_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">get_merged_foreign_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to construct a DataFrame that combines all the relevant information on foreign-owned compa-
nies, loaded and preprocessed from the "analytical_amne.xlsx" file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_merged_foreign_analytical_amne_data(self):
    &#34;&#34;&#34;
    This method allows to construct a DataFrame that combines all the relevant information on foreign-owned compa-
    nies, loaded and preprocessed from the &#34;analytical_amne.xlsx&#34; file.
    &#34;&#34;&#34;

    foreign_aamne = self.load_clean_foreign_analytical_amne_data()
    gross_output = self.load_clean_bilateral_gross_output_data()

    foreign_aamne = foreign_aamne.merge(
        gross_output,
        how=&#39;inner&#39;,
        on=&#39;COUNTRY_CODE&#39;
    )

    return foreign_aamne.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_domestic_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">get_unextended_domestic_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Equivalently to the "get_unextended_foreign_analytical_amne_data" method, this method allows to move from infor-
mation on gross output, gross value-added, etc. to proxies of sales to the host / headquarter country and sales
to any other country. Domestic sales are simply defined as (gross output - exports).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unextended_domestic_analytical_amne_data(self):
    &#34;&#34;&#34;
    Equivalently to the &#34;get_unextended_foreign_analytical_amne_data&#34; method, this method allows to move from infor-
    mation on gross output, gross value-added, etc. to proxies of sales to the host / headquarter country and sales
    to any other country. Domestic sales are simply defined as (gross output - exports).
    &#34;&#34;&#34;
    aamne_domestic = self.load_clean_domestic_analytical_amne_data()

    aamne_domestic[&#39;DOMESTIC_SALES&#39;] = (
        aamne_domestic[&#39;GROSS_OUTPUT&#39;] - aamne_domestic[&#39;EXPORTS&#39;]
    )
    aamne_domestic[&#39;SALES_TO_OTHER_COUNTRY&#39;] = aamne_domestic[&#39;EXPORTS&#39;].values

    aamne_domestic.drop(
        columns=[&#39;GROSS_OUTPUT&#39;, &#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;],
        inplace=True
    )

    return aamne_domestic.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_foreign_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">get_unextended_foreign_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>With the three methods defined above, we have obtained, for each in-sample country, information on the gross
output, gross value-added exports and imports that foreign-owned companies register. We want to deduce an ap-
proximation of the following three aggregates:</p>
<ul>
<li>sales of foreign-owned companies to the host country;</li>
<li>sales of foreign-owned companies to their headquarter country;</li>
<li>and sales of foreign-owned companies to any other country.</li>
</ul>
<p>The first one is approximated as (gross output - exports).</p>
<p>The second one is approximated as (exports * ratio of exports to the headquarter country). For each country con-
sidered, the ratio is assumed to be the same for all foreign-owned companies (simplifying assumption made neces-
sary because of the limited data at hand) and we therefore draw it from BEA data. If the country is absent from
BEA data, we take the ratio averaged across all countries in the BEA.</p>
<p>The third one is simply computed as (exports - sales to the heaquarter country).</p>
<p>Eventually, as we know that this distribution will be used to split the revenue variables of non-US multinatio-
nal companies, we exclude the US from these computations. We already have a gross output variable that excludes
the US and we approximate US exports from the BEA data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unextended_foreign_analytical_amne_data(self):
    &#34;&#34;&#34;
    With the three methods defined above, we have obtained, for each in-sample country, information on the gross
    output, gross value-added exports and imports that foreign-owned companies register. We want to deduce an ap-
    proximation of the following three aggregates:

    - sales of foreign-owned companies to the host country;
    - sales of foreign-owned companies to their headquarter country;
    - and sales of foreign-owned companies to any other country.

    The first one is approximated as (gross output - exports).

    The second one is approximated as (exports * ratio of exports to the headquarter country). For each country con-
    sidered, the ratio is assumed to be the same for all foreign-owned companies (simplifying assumption made neces-
    sary because of the limited data at hand) and we therefore draw it from BEA data. If the country is absent from
    BEA data, we take the ratio averaged across all countries in the BEA.

    The third one is simply computed as (exports - sales to the heaquarter country).

    Eventually, as we know that this distribution will be used to split the revenue variables of non-US multinatio-
    nal companies, we exclude the US from these computations. We already have a gross output variable that excludes
    the US and we approximate US exports from the BEA data.
    &#34;&#34;&#34;
    bea = self.bea.copy()

    #-- Average ratios used for countries that do not appear in the BEA data

    # Ratio of exports to total sales, used to deduce non-US exports
    self.imputation_exports_ratio = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum() / bea[&#39;TOTAL&#39;].sum()

    # Ratio of sales to the headquarter country to total sales outside the host country
    self.imputation_exports_to_US_ratio = (
        bea[&#39;TOTAL_US&#39;].sum() / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]).sum()
    )

    #-- Same computation on a per-country basis, used for countries that appear in both Analytical AMNE and BEA data
    bea[&#39;BEA_EXPORTS_RATIO&#39;] = (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;]) / bea[&#39;TOTAL&#39;]
    bea[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = bea[&#39;TOTAL_US&#39;] / (bea[&#39;TOTAL_OTHER_COUNTRY&#39;] + bea[&#39;TOTAL_US&#39;])

    # Using the method defined above, we get all the information on the activities of foreign-owned firms
    merged_df = self.get_merged_foreign_analytical_amne_data()

    # Activities in the US and in other countries are treated differently, we separate the two
    us_extract = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] == &#39;USA&#39;].copy()
    merged_df = merged_df[merged_df[&#39;COUNTRY_CODE&#39;] != &#39;USA&#39;].copy()

    # We add the US export and sales-to-headquarter ratios to the main DataFrame
    merged_df = merged_df.merge(
        bea[[&#39;CODE&#39;, &#39;BEA_EXPORTS_RATIO&#39;, &#39;BEA_EXPORTS_TO_US_RATIO&#39;]].copy(),
        how=&#39;left&#39;,
        left_on=&#39;COUNTRY_CODE&#39;, right_on=&#39;CODE&#39;
    )

    merged_df.drop(columns=[&#39;CODE&#39;], inplace=True)

    # We replace missing values due to the absence of some countries from BEA data, using the average ratios
    merged_df[&#39;BEA_EXPORTS_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_RATIO&#39;].fillna(self.imputation_exports_ratio)
    merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;] = merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;].fillna(
        self.imputation_exports_to_US_ratio
    )

    # We compute a proxy for the exports of non-US foreign-owned firms using the BEA export ratios
    merged_df[&#39;EXPORTS_EXCL_US&#39;] = (
        merged_df[&#39;EXPORTS&#39;] - (   # Exports of all foreign-owned firms
            merged_df[&#39;GROSS_OUTPUT_INCL_US&#39;] - merged_df[&#39;GROSS_OUTPUT_EXCL_US&#39;]   # Gross output of US-owned firms
        ) * merged_df[&#39;BEA_EXPORTS_RATIO&#39;]   # Export ratio of US firms
    )

    # We rename columns and filter out the ones that are not relevant anymore
    merged_df.drop(
        columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;BEA_EXPORTS_RATIO&#39;],
        inplace=True
    )

    merged_df.rename(
        columns={
            &#39;GROSS_OUTPUT_EXCL_US&#39;: &#39;TURNOVER&#39;,
            &#39;EXPORTS_EXCL_US&#39;: &#39;EXPORTS&#39;,
        },
        inplace=True
    )

    # We deduce from previous computations the three proxies that we are looking for
    merged_df[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = merged_df[&#39;TURNOVER&#39;] - merged_df[&#39;EXPORTS&#39;]
    merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] * merged_df[&#39;BEA_EXPORTS_TO_US_RATIO&#39;]
    merged_df[&#39;SALES_TO_OTHER_COUNTRY&#39;] = merged_df[&#39;EXPORTS&#39;] - merged_df[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

    merged_df.drop(
        columns=[&#39;TURNOVER&#39;, &#39;EXPORTS&#39;],
        inplace=True
    )

    # We compute equivalent aggregates for the US
    us_extract[&#39;SALES_TO_AFFILIATE_COUNTRY&#39;] = us_extract[&#39;GROSS_OUTPUT_INCL_US&#39;] - us_extract[&#39;EXPORTS&#39;]
    us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] * self.imputation_exports_to_US_ratio
    us_extract[&#39;SALES_TO_OTHER_COUNTRY&#39;] = us_extract[&#39;EXPORTS&#39;] - us_extract[&#39;SALES_TO_HEADQUARTER_COUNTRY&#39;]

    us_extract.drop(
        columns=[&#39;GROSS_VALUE_ADDED&#39;, &#39;EXPORTS&#39;, &#39;IMPORTS&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;],
        inplace=True
    )

    # And we concatenate the resulting DataFrames
    merged_df = pd.concat(
        [merged_df, us_extract],
        axis=0
    )

    return merged_df.reset_index(drop=True)</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_OECD_CbCR_data"><code class="name flex">
<span>def <span class="ident">load_OECD_CbCR_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If, when instantiating the AnalyticalAMNEPreprocessor object, the option "load_OECD_data=False" was chosen, this
method allows to load the OECD's country-by-country data and to save it in an "oecd" attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_OECD_CbCR_data(self):
    &#34;&#34;&#34;
    If, when instantiating the AnalyticalAMNEPreprocessor object, the option &#34;load_OECD_data=False&#34; was chosen, this
    method allows to load the OECD&#39;s country-by-country data and to save it in an &#34;oecd&#34; attribute.
    &#34;&#34;&#34;
    self.cbcr_preprocessor = CbCRPreprocessor()
    self.oecd = self.cbcr_preprocessor.get_preprocessed_revenue_data()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_bilateral_gross_output_data"><code class="name flex">
<span>def <span class="ident">load_clean_bilateral_gross_output_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to load and clean the data from the first tab of the "analytical_amne.xlsx" file. Indeed, the
dataset also provides a bilateral mapping of gross output between host countries and the jurisdictions where
companies are ultimately headquartered.</p>
<p>Focusing on 2016 data, we sum these results over all sectors of activity and all jurisdictions of ultimate
ownership, so as to complement the previous dataset with gross output. As explained in more details in the PDF
report, we also compute the total gross output excluding US-headquartered multinational enterprises.</p>
<p>This method relies on a function, "compute_foreign_owned_gross_output", defined in the "utils.py" file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_clean_bilateral_gross_output_data(self):
    &#34;&#34;&#34;
    This method allows to load and clean the data from the first tab of the &#34;analytical_amne.xlsx&#34; file. Indeed, the
    dataset also provides a bilateral mapping of gross output between host countries and the jurisdictions where
    companies are ultimately headquartered.

    Focusing on 2016 data, we sum these results over all sectors of activity and all jurisdictions of ultimate
    ownership, so as to complement the previous dataset with gross output. As explained in more details in the PDF
    report, we also compute the total gross output excluding US-headquartered multinational enterprises.

    This method relies on a function, &#34;compute_foreign_owned_gross_output&#34;, defined in the &#34;utils.py&#34; file.
    &#34;&#34;&#34;

    # We read the first tab of the spreadsheet
    gross_output = pd.read_excel(
        self.path_to_analytical_amne,
        sheet_name=self.tab_1,
        engine=&#39;openpyxl&#39;
    )

    gross_output = gross_output[gross_output[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR
    gross_output = gross_output[gross_output[&#39;cou&#39;] != &#39;ROW&#39;].copy()

    gross_output = gross_output.drop(columns=&#39;year&#39;).groupby(&#39;cou&#39;).sum().reset_index()

    # Relying on a function defined in &#34;utils.py&#34;, we compute for each country the gross output registered there by
    # foreign-owned multinationals, including the US-headquartered ones
    gross_output[&#39;GROSS_OUTPUT_INCL_US&#39;] = gross_output.apply(
        lambda row: compute_foreign_owned_gross_output(row, include_US=True),
        axis=1
    )

    # We do the same, this time excluding US-owned multinational companies
    gross_output[&#39;GROSS_OUTPUT_EXCL_US&#39;] = gross_output.apply(
        lambda row: compute_foreign_owned_gross_output(row, include_US=False),
        axis=1
    )

    # We restrict the dataset to the necessary variables
    gross_output = gross_output[[&#39;cou&#39;, &#39;GROSS_OUTPUT_INCL_US&#39;, &#39;GROSS_OUTPUT_EXCL_US&#39;]].copy()

    gross_output.rename(
        columns={
            &#39;cou&#39;: &#39;COUNTRY_CODE&#39;
        },
        inplace=True
    )

    return gross_output.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_domestic_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">load_clean_domestic_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to load and clean data from the complementary Excel file of the OECD's Analytical AMNE data-
base, "analytical_amne_domesticMNEs.xlsx". It provides information on and estimations of the gross output, gross
value-added, exports and imports of domestically-owned companies.</p>
<p>It allows to distinguish between the domestic branches of multinational enterprises and purely local firms.
Here also, variables are further broken down by industry.</p>
<p>We concentrate on 2016 data and only consider the rows corresponding to the activities of multinational enter-
prises. We sum the four variables over all sectors of activity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_clean_domestic_analytical_amne_data(self):
    &#34;&#34;&#34;
    This method allows to load and clean data from the complementary Excel file of the OECD&#39;s Analytical AMNE data-
    base, &#34;analytical_amne_domesticMNEs.xlsx&#34;. It provides information on and estimations of the gross output, gross
    value-added, exports and imports of domestically-owned companies.

    It allows to distinguish between the domestic branches of multinational enterprises and purely local firms.
    Here also, variables are further broken down by industry.

    We concentrate on 2016 data and only consider the rows corresponding to the activities of multinational enter-
    prises. We sum the four variables over all sectors of activity.
    &#34;&#34;&#34;

    # We read the Excel file; paths are defined when instantiating the AnalyticalAMNEPreprocessor object
    aamne_domestic = pd.read_excel(
        self.path_to_analytical_amne_domestic,
        sheet_name=self.domestic_aamne_tab,
        engine=&#39;openpyxl&#39;
    )

    aamne_domestic = aamne_domestic[aamne_domestic[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data
    aamne_domestic = aamne_domestic[aamne_domestic[&#39;own&#39;] == &#39;MNE&#39;].copy()   # And on multinational companies
    aamne_domestic = aamne_domestic[aamne_domestic[&#39;cou&#39;] != &#39;ROW&#39;].copy()

    aamne_domestic.drop(
        columns=[&#39;flag_go&#39;, &#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;, &#39;year&#39;, &#39;own&#39;],
        inplace=True
    )

    # We consider all sectors of activity together and thus group by host country
    aamne_domestic = aamne_domestic.groupby(&#39;cou&#39;).sum().reset_index()

    aamne_domestic.rename(
        columns={
            &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
            &#39;go&#39;: &#39;GROSS_OUTPUT&#39;,
            &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
            &#39;exgr&#39;: &#39;EXPORTS&#39;,
            &#39;imgr&#39;: &#39;IMPORTS&#39;
        },
        inplace=True
    )

    return aamne_domestic.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_foreign_analytical_amne_data"><code class="name flex">
<span>def <span class="ident">load_clean_foreign_analytical_amne_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to load and clean the data from the second tab of the "analytical_amne.xlsx" file. This file
provides information and estimations relative to the activities of foreign-owned and domestically-owned compa-
nies in a sample of countries, from 2005 to 2016.</p>
<p>For each country, the dataset indicates the gross value-added, exports and imports of the foreign subsidiaries
of multinational enterprises (foreign-owned companies) and of locally-owned companies. These variables are fur-
ther broken down by industry.</p>
<p>We concentrate on 2016 data to align with country-by-country statistics and only consider the rows corresponding
to foreign-owned companies. We further sum the three variables over all sectors of activity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_clean_foreign_analytical_amne_data(self):
    &#34;&#34;&#34;
    This method allows to load and clean the data from the second tab of the &#34;analytical_amne.xlsx&#34; file. This file
    provides information and estimations relative to the activities of foreign-owned and domestically-owned compa-
    nies in a sample of countries, from 2005 to 2016.

    For each country, the dataset indicates the gross value-added, exports and imports of the foreign subsidiaries
    of multinational enterprises (foreign-owned companies) and of locally-owned companies. These variables are fur-
    ther broken down by industry.

    We concentrate on 2016 data to align with country-by-country statistics and only consider the rows corresponding
    to foreign-owned companies. We further sum the three variables over all sectors of activity.
    &#34;&#34;&#34;

    # We read the second tab of the spreadsheet
    aamne = pd.read_excel(
        self.path_to_analytical_amne,
        sheet_name=self.tab_2,
        engine=&#39;openpyxl&#39;
    )

    aamne.drop(
        columns=[&#39;flag_gva&#39;, &#39;flag_exgr&#39;, &#39;flag_imgr&#39;],
        inplace=True
    )

    aamne = aamne[aamne[&#39;year&#39;] == 2016].copy()   # We focus on 2016 data to align with CbCR data
    aamne = aamne[aamne[&#39;own&#39;] == &#39;F&#39;].copy()     # And on the activities of foreign-owned companies
    aamne = aamne[aamne[&#39;cou&#39;] != &#39;ROW&#39;].copy()

    aamne.drop(
        columns=[&#39;year&#39;, &#39;own&#39;],
        inplace=True
    )

    aamne.reset_index(drop=True, inplace=True)

    # We consider all sectors of activity and therefore group by countries
    aamne_grouped = aamne.groupby(&#39;cou&#39;).sum().reset_index()

    aamne_grouped.rename(
        columns={
            &#39;cou&#39;: &#39;COUNTRY_CODE&#39;,
            &#39;gva&#39;: &#39;GROSS_VALUE_ADDED&#39;,
            &#39;exgr&#39;: &#39;EXPORTS&#39;,
            &#39;imgr&#39;: &#39;IMPORTS&#39;
        },
        inplace=True
    )

    return aamne_grouped.copy()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="destination_based_sales" href="index.html">destination_based_sales</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor">AnalyticalAMNEPreprocessor</a></code></h4>
<ul class="">
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_domestic_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_domestic_analytical_amne_data">get_extended_domestic_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_foreign_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_extended_foreign_analytical_amne_data">get_extended_foreign_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_merged_foreign_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_merged_foreign_analytical_amne_data">get_merged_foreign_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_domestic_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_domestic_analytical_amne_data">get_unextended_domestic_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_foreign_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.get_unextended_foreign_analytical_amne_data">get_unextended_foreign_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_OECD_CbCR_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_OECD_CbCR_data">load_OECD_CbCR_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_bilateral_gross_output_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_bilateral_gross_output_data">load_clean_bilateral_gross_output_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_domestic_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_domestic_analytical_amne_data">load_clean_domestic_analytical_amne_data</a></code></li>
<li><code><a title="destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_foreign_analytical_amne_data" href="#destination_based_sales.analytical_amne.AnalyticalAMNEPreprocessor.load_clean_foreign_analytical_amne_data">load_clean_foreign_analytical_amne_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>