<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>destination_based_sales.per_industry API documentation</title>
<meta name="description" content="This module is dedicated to the industry-specific analyses described in Section 4.a. of the PDF report of August 2021.
Indeed, the US Internal Revenue …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>destination_based_sales.per_industry</code></h1>
</header>
<section id="section-intro">
<p>This module is dedicated to the industry-specific analyses described in Section 4.a. of the PDF report of August 2021.
Indeed, the US Internal Revenue Service (IRS) provides a breakdown of its country-by-country statistics based on the
main sector of activity of the parent company of the multinational group. We use it to highlight the differences, from
an industry to another, in the concentration of foreign sales in tax havens.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is dedicated to the industry-specific analyses described in Section 4.a. of the PDF report of August 2021.
Indeed, the US Internal Revenue Service (IRS) provides a breakdown of its country-by-country statistics based on the
main sector of activity of the parent company of the multinational group. We use it to highlight the differences, from
an industry to another, in the concentration of foreign sales in tax havens.
&#34;&#34;&#34;


########################################################################################################################
# --- Imports

import os
import json

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns

from destination_based_sales.utils import CONTINENT_CODES_TO_IMPUTE_TRADE


########################################################################################################################
# --- Diverse

path_to_dir = os.path.dirname(os.path.abspath(__file__))
path_to_GNI_data = os.path.join(path_to_dir, &#39;data&#39;, &#39;gross_national_income.csv&#39;)
path_to_geographies = os.path.join(path_to_dir, &#39;data&#39;, &#39;geographies.csv&#39;)
path_to_tax_haven_list = os.path.join(path_to_dir, &#39;data&#39;, &#39;tax_havens.csv&#39;)
path_to_industry_names_mapping = os.path.join(path_to_dir, &#39;data&#39;, &#39;industry_names_mapping.json&#39;)

with open(path_to_industry_names_mapping) as file:
    industry_names_mapping = json.loads(file.read())


########################################################################################################################
# --- Content

class PerIndustryAnalyser:

    def __init__(
        self,
        year,
        path_to_dir=path_to_dir,
        path_to_tax_haven_list=path_to_tax_haven_list,
        path_to_geographies=path_to_geographies
    ):
        &#34;&#34;&#34;
        The logic for loading, preprocessing and analysing the industry-specific country-by-country statistics of the
        IRS is encapsulated in a Python class, PerIndustryAnalyser. This is the instantiation function of this class,
        which takes as arguments:

        - the year to consider;
        - the string path to the directory where this Python file is located;
        - the string path to the list of tax havens;
        - the string path to the &#34;geographies.csv&#34; file.
        &#34;&#34;&#34;
        if year not in [2016, 2017, 2018]:
            raise Exception(&#39;For now, only the financial years from 2016 to 2018 (included) are covered.&#39;)

        self.year = year

        # We load the list of tax havens in a dedicated attribute
        self.path_to_tax_haven_list = path_to_tax_haven_list
        self.tax_havens = pd.read_csv(self.path_to_tax_haven_list)

        self.path_to_dir = path_to_dir
        self.path_to_geographies = path_to_geographies

    def load_clean_data(
        self,
        exclude_all_jurisdictions=True
    ):
        &#34;&#34;&#34;
        This function allows to load and preprocess the industry-specific country-by-country data of the IRS.

        It takes as argument a boolean, &#34;exclude_all_jurisdictions&#34;, that determines whether or not to exclude the in-
        dustry-level totals from the dataset. These are characterised by &#34;All jurisdictions&#34; as a partner country.
        &#34;&#34;&#34;

        # Loading the data from the corresponding Excel file
        path_to_industry_data = os.path.join(
            self.path_to_dir,
            &#39;data&#39;,
            str(self.year),
            f&#39;{self.year - 2000}it02cbc.xlsx&#39;
        )

        data = pd.read_excel(
            path_to_industry_data,
            engine=&#39;openpyxl&#39;
        )

        # Eliminating irrelevant columns and rows
        data = data[data.columns[:6]].copy()

        data.columns = [
            &#39;INDUSTRY&#39;,
            &#39;AFFILIATE_COUNTRY_NAME&#39;,
            &#39;NB_REPORTING_MNEs&#39;,
            &#39;UNRELATED_PARTY_REVENUES&#39;,
            &#39;RELATED_PARTY_REVENUES&#39;,
            &#39;TOTAL_REVENUES&#39;
        ]

        data = data[
            data.isnull().sum(axis=1) != len(data.columns)
        ].copy()
        data = data.iloc[4:-7].copy()

        data.reset_index(drop=True, inplace=True)

        # Adding the right industry name to each observation
        industry_indices = list(data[~data[&#39;INDUSTRY&#39;].isnull()].index)

        industries = {}

        for i in range(len(industry_indices)):

            if i &lt; len(industry_indices) - 1:
                restricted_df = data.loc[industry_indices[i]:industry_indices[i + 1] - 1].copy()

            else:
                restricted_df = data.loc[industry_indices[i]:].copy()

            industry = restricted_df[&#39;INDUSTRY&#39;].iloc[0]
            restricted_df[&#39;INDUSTRY&#39;] = industry
            industries[industry] = restricted_df.copy()

        data = industries[list(industries.keys())[0]].copy()

        for key, value in industries.items():
            if key == list(industries.keys())[0]:
                continue

            data = pd.concat([data, value], axis=0)

        # Eliminating irrelevant observations
        if exclude_all_jurisdictions:
            data = data[
                ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;Stateless entities and other country&#39;])
            ].copy()

        else:
            data = data[
                data[&#39;AFFILIATE_COUNTRY_NAME&#39;] != &#39;Stateless entities and other country&#39;
            ].copy()

        data = data[
            ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
                lambda country_name: &#39;total&#39; in country_name.lower()
            )
        ].copy()

        data = data[
            data.drop(columns=[&#39;NB_REPORTING_MNEs&#39;]).applymap(
                lambda x: isinstance(x, str) and x == &#39;d&#39;
            ).sum(axis=1) == 0
        ].copy()

        # Renaming continental aggregates and a few specific partner jurisdictions
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            (
                lambda country_name: f&#39;Other {country_name.split(&#34;,&#34;)[0].replace(&#34;&amp;&#34;, &#34;and&#34;)}&#39;
                if &#39;other&#39; in country_name.lower() else country_name
            )
        )

        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;United Kingdom&#39; if &#39;United Kingdom&#39; in country_name else country_name
        )
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;Korea&#39; if country_name.startswith(&#39;Korea&#39;) else country_name
        )
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;Congo&#39; if country_name.endswith(&#39;(Brazzaville)&#39;) else country_name
        )

        # Adding alpha-3 country codes
        geographies = pd.read_csv(self.path_to_geographies)

        data = data.merge(
            geographies[[&#39;NAME&#39;, &#39;CODE&#39;]],
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_NAME&#39;, right_on=&#39;NAME&#39;
        )

        data.drop(columns=[&#39;NAME&#39;], inplace=True)

        data[&#39;CODE&#39;] = data.apply(
            (
                lambda row: &#39;OASIAOCN&#39; if isinstance(row[&#39;CODE&#39;], float) and np.isnan(row[&#39;CODE&#39;])
                and row[&#39;AFFILIATE_COUNTRY_NAME&#39;] == &#39;Other Asia and Oceania&#39; else row[&#39;CODE&#39;]
            ),
            axis=1
        )

        data.rename(
            columns={
                &#39;CODE&#39;: &#39;AFFILIATE_COUNTRY_CODE&#39;
            },
            inplace=True
        )

        data.reset_index(drop=True, inplace=True)

        # Renaming industries for convenience
        data[&#39;INDUSTRY&#39;] = data[&#39;INDUSTRY&#39;].map(
            lambda industry: industry_names_mapping.get(industry, industry)
        )

        return data.copy()

    def load_data_with_GNI(self, dropna=False, path_to_GNI_data=path_to_GNI_data):
        &#34;&#34;&#34;
        Building upon the previous method, &#34;load_clean_data&#34;, this method allows to load and preprocess the industry-
        specific country-by-country data while adding the Gross National Income (GNI) of each partner country, for the
        corresponding year. It takes two arguments:

        - a boolean, &#34;dropna&#34;, indicating whether or not to exclude the partner countries for which we lack the GNI;
        - the string path to the file containing GNI data.
        &#34;&#34;&#34;

        # Loading and cleaning industry-specific country-by-country data
        data = self.load_clean_data()

        # Loading and preprocessing Gross National Income (GNI) data
        gross_national_income = pd.read_csv(path_to_GNI_data, delimiter=&#39;;&#39;)
        gross_national_income = gross_national_income[[&#39;COUNTRY_CODE&#39;, f&#39;GNI_{self.year}&#39;]].copy()

        gross_national_income[f&#39;GNI_{self.year}&#39;] = gross_national_income[f&#39;GNI_{self.year}&#39;].map(
            lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
        ).astype(float)

        # Merging the two datasets on partner country codes
        data = data.merge(
            gross_national_income,
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        data.drop(columns=[&#39;COUNTRY_CODE&#39;], inplace=True)

        if dropna:
            data.dropna(inplace=True)

        return data.copy()

    def get_industry_overview_table(self, output_excel=True):
        &#34;&#34;&#34;
        This method allows to output the industry overview table that shows, for each year in the sample period, the
        distribution of US total unrelated-party revenues and foreign unrelated-party revenues between industries. It
        corresponds to Table 3 in the PDF report of August 2021. The boolean argument, &#34;output_excel&#34;, determines
        whether to save the table in an Excel file (change the target file path before using this method with
        &#34;output_excel=True&#34;).
        &#34;&#34;&#34;
        final_output = {}

        for year in [2016, 2017, 2018]:
            # We instantiate an industry-specific analyser for each year
            analyser = PerIndustryAnalyser(year=year)

            # Loading the data
            data = analyser.load_clean_data(exclude_all_jurisdictions=False)

            # Focusing on industry totals and US-US rows
            data = data[data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;United States&#39;])].copy()

            # Eliminating irrelevant columns
            data.drop(
                columns=[
                    &#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;NB_REPORTING_MNEs&#39;,
                    &#39;RELATED_PARTY_REVENUES&#39;, &#39;TOTAL_REVENUES&#39;
                ],
                inplace=True
            )

            # We pivot the DataFrame to show the revenues of each industry in all jurisdictions and in the US
            df = data.pivot(
                index=&#39;INDUSTRY&#39;,
                columns=&#39;AFFILIATE_COUNTRY_NAME&#39;,
                values=&#39;UNRELATED_PARTY_REVENUES&#39;
            ).reset_index()

            # Foreign unrelated-party revenues simply correspond to the total minus the US-US revenues
            df[&#39;FOREIGN_UPR&#39;] = df[&#39;All jurisdictions&#39;] - df[&#39;United States&#39;]

            # We move from absolute amounts to shares / a distribution
            df[&#39;Share of total unrelated-party revenues (%)&#39;] = (
                df[&#39;All jurisdictions&#39;] / df[&#39;All jurisdictions&#39;].sum() * 100
            )
            df[&#39;Share of foreign unrelated-party revenues (%)&#39;] = df[&#39;FOREIGN_UPR&#39;] / df[&#39;FOREIGN_UPR&#39;].sum() * 100

            df.drop(columns=[&#39;All jurisdictions&#39;, &#39;United States&#39;, &#39;FOREIGN_UPR&#39;], inplace=True)

            # Ranking industries based on decreasing importance in the distribution
            df.sort_values(by=&#39;Share of foreign unrelated-party revenues (%)&#39;, ascending=False, inplace=True)

            final_output[year] = df.copy()

        # Outputting the Excel file if relevant
        if output_excel:
            path_to_excel_file = &#39;/Users/Paul-Emmanuel/Desktop/industry_overview_table_PYTHON_OUTPUT.xlsx&#39;

            with pd.ExcelWriter(path_to_excel_file, engine=&#39;xlsxwriter&#39;) as writer:
                for key, value in final_output.items():
                    value.to_excel(writer, sheet_name=str(key), index=False)

        return final_output.copy()

    def plot_industry_specific_charts(self, save_PNG=False, path_to_folder=None):
        &#34;&#34;&#34;
        This method allows to output the graphs that show the relationship between partner jurisdictions’ share of US
        multinational companies’ foreign unrelated-party revenues and their share of Gross National Income (GNI),
        broken down by industry group. These correspond to Figure E.1 of the PDF report of August 2021.

        The method takes two arguments used to save the output charts in a PNG file. This requires to set the boolean
        &#34;save_PNG&#34; to True and to pass, in &#34;path_to_folder&#34;, the string path to the target folder.
        &#34;&#34;&#34;

        # Setting Matplotlib parameters
        plt.rcParams.update({&#39;font.size&#39;: 18})

        if save_PNG and path_to_folder is None:
            raise Exception(&#39;To save the figure as a PNG, you must indicate the target folder as an argument.&#39;)

        # Loading cleaned data with GNI data (eliminating rows for which we have no GNI data)
        data = self.load_data_with_GNI(dropna=True)

        fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(25, 40))

        # Figure displays one graph per industry group
        for industry, ax in zip(data[&#39;INDUSTRY&#39;].unique(), axes.flatten()):

            # Restricting the dataset to the industry group under consideration and excluding the US-US row
            restricted_df = data[
                np.logical_and(
                    data[&#39;INDUSTRY&#39;] == industry,
                    data[&#39;AFFILIATE_COUNTRY_CODE&#39;] != &#39;USA&#39;
                )
            ].copy()

            # Computing each partner country&#39;s share of US, industry-specific foreign unrelated-party revenues
            restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;] = (
                restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].astype(float) /
                restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].sum()
            )

            # Computing each partner country&#39;s share of GNI
            restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;] = (
                restricted_df[f&#39;GNI_{self.year}&#39;] / restricted_df[f&#39;GNI_{self.year}&#39;].sum()
            )

            # Computing the correlation between the two shares for the industry under consideration
            correlation = np.corrcoef(
                restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;],
                restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;]
            )[1, 0]

            # Distinguishing non-havens, tax havens and NAFTA members
            restricted_df[&#39;Category&#39;] = (
                restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin(self.tax_havens[&#39;CODE&#39;].unique()) * 1
                + restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin([&#39;CAN&#39;, &#39;MEX&#39;]) * 2
            )
            restricted_df[&#39;Category&#39;] = restricted_df[&#39;Category&#39;].map({0: &#39;Other&#39;, 1: &#39;Tax haven&#39;, 2: &#39;NAFTA member&#39;})

            restricted_df.rename(
                columns={
                    f&#39;SHARE_OF_GNI_{self.year}&#39;: f&#39;Share of total {self.year} GNI (%)&#39;,
                    &#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;: &#39;Share of total unrelated-party revenues (%)&#39;
                },
                inplace=True
            )

            # Building the graph with the indicative regression line and the scattered plot
            sns.regplot(
                x=f&#39;Share of total {self.year} GNI (%)&#39;,
                y=&#39;Share of total unrelated-party revenues (%)&#39;,
                data=restricted_df,
                ci=None,
                ax=ax
            )

            sns.scatterplot(
                x=f&#39;Share of total {self.year} GNI (%)&#39;,
                y=&#39;Share of total unrelated-party revenues (%)&#39;,
                data=restricted_df,
                hue=&#39;Category&#39;,
                palette={
                    &#39;Other&#39;: &#39;darkblue&#39;, &#39;Tax haven&#39;: &#39;darkred&#39;, &#39;NAFTA member&#39;: &#39;darkgreen&#39;
                },
                s=80,
                ax=ax
            )

            # Title indicating the industry being considered and the correlation between the share of foreign unrelated-
            # party revenues and the share of GNI
            ax.set_title(f&#39;{industry} - Correlation of {round(correlation, 2)}&#39;)

        plt.show()

        # Saving the figure into a PNG file if relevant
        if save_PNG:
            fig.savefig(
                os.path.join(
                    path_to_folder,
                    f&#39;industry_specific_charts_{self.year}.png&#39;
                )
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="destination_based_sales.per_industry.PerIndustryAnalyser"><code class="flex name class">
<span>class <span class="ident">PerIndustryAnalyser</span></span>
<span>(</span><span>year, path_to_dir='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales', path_to_tax_haven_list='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/tax_havens.csv', path_to_geographies='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/geographies.csv')</span>
</code></dt>
<dd>
<div class="desc"><p>The logic for loading, preprocessing and analysing the industry-specific country-by-country statistics of the
IRS is encapsulated in a Python class, PerIndustryAnalyser. This is the instantiation function of this class,
which takes as arguments:</p>
<ul>
<li>the year to consider;</li>
<li>the string path to the directory where this Python file is located;</li>
<li>the string path to the list of tax havens;</li>
<li>the string path to the "geographies.csv" file.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerIndustryAnalyser:

    def __init__(
        self,
        year,
        path_to_dir=path_to_dir,
        path_to_tax_haven_list=path_to_tax_haven_list,
        path_to_geographies=path_to_geographies
    ):
        &#34;&#34;&#34;
        The logic for loading, preprocessing and analysing the industry-specific country-by-country statistics of the
        IRS is encapsulated in a Python class, PerIndustryAnalyser. This is the instantiation function of this class,
        which takes as arguments:

        - the year to consider;
        - the string path to the directory where this Python file is located;
        - the string path to the list of tax havens;
        - the string path to the &#34;geographies.csv&#34; file.
        &#34;&#34;&#34;
        if year not in [2016, 2017, 2018]:
            raise Exception(&#39;For now, only the financial years from 2016 to 2018 (included) are covered.&#39;)

        self.year = year

        # We load the list of tax havens in a dedicated attribute
        self.path_to_tax_haven_list = path_to_tax_haven_list
        self.tax_havens = pd.read_csv(self.path_to_tax_haven_list)

        self.path_to_dir = path_to_dir
        self.path_to_geographies = path_to_geographies

    def load_clean_data(
        self,
        exclude_all_jurisdictions=True
    ):
        &#34;&#34;&#34;
        This function allows to load and preprocess the industry-specific country-by-country data of the IRS.

        It takes as argument a boolean, &#34;exclude_all_jurisdictions&#34;, that determines whether or not to exclude the in-
        dustry-level totals from the dataset. These are characterised by &#34;All jurisdictions&#34; as a partner country.
        &#34;&#34;&#34;

        # Loading the data from the corresponding Excel file
        path_to_industry_data = os.path.join(
            self.path_to_dir,
            &#39;data&#39;,
            str(self.year),
            f&#39;{self.year - 2000}it02cbc.xlsx&#39;
        )

        data = pd.read_excel(
            path_to_industry_data,
            engine=&#39;openpyxl&#39;
        )

        # Eliminating irrelevant columns and rows
        data = data[data.columns[:6]].copy()

        data.columns = [
            &#39;INDUSTRY&#39;,
            &#39;AFFILIATE_COUNTRY_NAME&#39;,
            &#39;NB_REPORTING_MNEs&#39;,
            &#39;UNRELATED_PARTY_REVENUES&#39;,
            &#39;RELATED_PARTY_REVENUES&#39;,
            &#39;TOTAL_REVENUES&#39;
        ]

        data = data[
            data.isnull().sum(axis=1) != len(data.columns)
        ].copy()
        data = data.iloc[4:-7].copy()

        data.reset_index(drop=True, inplace=True)

        # Adding the right industry name to each observation
        industry_indices = list(data[~data[&#39;INDUSTRY&#39;].isnull()].index)

        industries = {}

        for i in range(len(industry_indices)):

            if i &lt; len(industry_indices) - 1:
                restricted_df = data.loc[industry_indices[i]:industry_indices[i + 1] - 1].copy()

            else:
                restricted_df = data.loc[industry_indices[i]:].copy()

            industry = restricted_df[&#39;INDUSTRY&#39;].iloc[0]
            restricted_df[&#39;INDUSTRY&#39;] = industry
            industries[industry] = restricted_df.copy()

        data = industries[list(industries.keys())[0]].copy()

        for key, value in industries.items():
            if key == list(industries.keys())[0]:
                continue

            data = pd.concat([data, value], axis=0)

        # Eliminating irrelevant observations
        if exclude_all_jurisdictions:
            data = data[
                ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;Stateless entities and other country&#39;])
            ].copy()

        else:
            data = data[
                data[&#39;AFFILIATE_COUNTRY_NAME&#39;] != &#39;Stateless entities and other country&#39;
            ].copy()

        data = data[
            ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
                lambda country_name: &#39;total&#39; in country_name.lower()
            )
        ].copy()

        data = data[
            data.drop(columns=[&#39;NB_REPORTING_MNEs&#39;]).applymap(
                lambda x: isinstance(x, str) and x == &#39;d&#39;
            ).sum(axis=1) == 0
        ].copy()

        # Renaming continental aggregates and a few specific partner jurisdictions
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            (
                lambda country_name: f&#39;Other {country_name.split(&#34;,&#34;)[0].replace(&#34;&amp;&#34;, &#34;and&#34;)}&#39;
                if &#39;other&#39; in country_name.lower() else country_name
            )
        )

        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;United Kingdom&#39; if &#39;United Kingdom&#39; in country_name else country_name
        )
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;Korea&#39; if country_name.startswith(&#39;Korea&#39;) else country_name
        )
        data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;Congo&#39; if country_name.endswith(&#39;(Brazzaville)&#39;) else country_name
        )

        # Adding alpha-3 country codes
        geographies = pd.read_csv(self.path_to_geographies)

        data = data.merge(
            geographies[[&#39;NAME&#39;, &#39;CODE&#39;]],
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_NAME&#39;, right_on=&#39;NAME&#39;
        )

        data.drop(columns=[&#39;NAME&#39;], inplace=True)

        data[&#39;CODE&#39;] = data.apply(
            (
                lambda row: &#39;OASIAOCN&#39; if isinstance(row[&#39;CODE&#39;], float) and np.isnan(row[&#39;CODE&#39;])
                and row[&#39;AFFILIATE_COUNTRY_NAME&#39;] == &#39;Other Asia and Oceania&#39; else row[&#39;CODE&#39;]
            ),
            axis=1
        )

        data.rename(
            columns={
                &#39;CODE&#39;: &#39;AFFILIATE_COUNTRY_CODE&#39;
            },
            inplace=True
        )

        data.reset_index(drop=True, inplace=True)

        # Renaming industries for convenience
        data[&#39;INDUSTRY&#39;] = data[&#39;INDUSTRY&#39;].map(
            lambda industry: industry_names_mapping.get(industry, industry)
        )

        return data.copy()

    def load_data_with_GNI(self, dropna=False, path_to_GNI_data=path_to_GNI_data):
        &#34;&#34;&#34;
        Building upon the previous method, &#34;load_clean_data&#34;, this method allows to load and preprocess the industry-
        specific country-by-country data while adding the Gross National Income (GNI) of each partner country, for the
        corresponding year. It takes two arguments:

        - a boolean, &#34;dropna&#34;, indicating whether or not to exclude the partner countries for which we lack the GNI;
        - the string path to the file containing GNI data.
        &#34;&#34;&#34;

        # Loading and cleaning industry-specific country-by-country data
        data = self.load_clean_data()

        # Loading and preprocessing Gross National Income (GNI) data
        gross_national_income = pd.read_csv(path_to_GNI_data, delimiter=&#39;;&#39;)
        gross_national_income = gross_national_income[[&#39;COUNTRY_CODE&#39;, f&#39;GNI_{self.year}&#39;]].copy()

        gross_national_income[f&#39;GNI_{self.year}&#39;] = gross_national_income[f&#39;GNI_{self.year}&#39;].map(
            lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
        ).astype(float)

        # Merging the two datasets on partner country codes
        data = data.merge(
            gross_national_income,
            how=&#39;left&#39;,
            left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
        )

        data.drop(columns=[&#39;COUNTRY_CODE&#39;], inplace=True)

        if dropna:
            data.dropna(inplace=True)

        return data.copy()

    def get_industry_overview_table(self, output_excel=True):
        &#34;&#34;&#34;
        This method allows to output the industry overview table that shows, for each year in the sample period, the
        distribution of US total unrelated-party revenues and foreign unrelated-party revenues between industries. It
        corresponds to Table 3 in the PDF report of August 2021. The boolean argument, &#34;output_excel&#34;, determines
        whether to save the table in an Excel file (change the target file path before using this method with
        &#34;output_excel=True&#34;).
        &#34;&#34;&#34;
        final_output = {}

        for year in [2016, 2017, 2018]:
            # We instantiate an industry-specific analyser for each year
            analyser = PerIndustryAnalyser(year=year)

            # Loading the data
            data = analyser.load_clean_data(exclude_all_jurisdictions=False)

            # Focusing on industry totals and US-US rows
            data = data[data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;United States&#39;])].copy()

            # Eliminating irrelevant columns
            data.drop(
                columns=[
                    &#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;NB_REPORTING_MNEs&#39;,
                    &#39;RELATED_PARTY_REVENUES&#39;, &#39;TOTAL_REVENUES&#39;
                ],
                inplace=True
            )

            # We pivot the DataFrame to show the revenues of each industry in all jurisdictions and in the US
            df = data.pivot(
                index=&#39;INDUSTRY&#39;,
                columns=&#39;AFFILIATE_COUNTRY_NAME&#39;,
                values=&#39;UNRELATED_PARTY_REVENUES&#39;
            ).reset_index()

            # Foreign unrelated-party revenues simply correspond to the total minus the US-US revenues
            df[&#39;FOREIGN_UPR&#39;] = df[&#39;All jurisdictions&#39;] - df[&#39;United States&#39;]

            # We move from absolute amounts to shares / a distribution
            df[&#39;Share of total unrelated-party revenues (%)&#39;] = (
                df[&#39;All jurisdictions&#39;] / df[&#39;All jurisdictions&#39;].sum() * 100
            )
            df[&#39;Share of foreign unrelated-party revenues (%)&#39;] = df[&#39;FOREIGN_UPR&#39;] / df[&#39;FOREIGN_UPR&#39;].sum() * 100

            df.drop(columns=[&#39;All jurisdictions&#39;, &#39;United States&#39;, &#39;FOREIGN_UPR&#39;], inplace=True)

            # Ranking industries based on decreasing importance in the distribution
            df.sort_values(by=&#39;Share of foreign unrelated-party revenues (%)&#39;, ascending=False, inplace=True)

            final_output[year] = df.copy()

        # Outputting the Excel file if relevant
        if output_excel:
            path_to_excel_file = &#39;/Users/Paul-Emmanuel/Desktop/industry_overview_table_PYTHON_OUTPUT.xlsx&#39;

            with pd.ExcelWriter(path_to_excel_file, engine=&#39;xlsxwriter&#39;) as writer:
                for key, value in final_output.items():
                    value.to_excel(writer, sheet_name=str(key), index=False)

        return final_output.copy()

    def plot_industry_specific_charts(self, save_PNG=False, path_to_folder=None):
        &#34;&#34;&#34;
        This method allows to output the graphs that show the relationship between partner jurisdictions’ share of US
        multinational companies’ foreign unrelated-party revenues and their share of Gross National Income (GNI),
        broken down by industry group. These correspond to Figure E.1 of the PDF report of August 2021.

        The method takes two arguments used to save the output charts in a PNG file. This requires to set the boolean
        &#34;save_PNG&#34; to True and to pass, in &#34;path_to_folder&#34;, the string path to the target folder.
        &#34;&#34;&#34;

        # Setting Matplotlib parameters
        plt.rcParams.update({&#39;font.size&#39;: 18})

        if save_PNG and path_to_folder is None:
            raise Exception(&#39;To save the figure as a PNG, you must indicate the target folder as an argument.&#39;)

        # Loading cleaned data with GNI data (eliminating rows for which we have no GNI data)
        data = self.load_data_with_GNI(dropna=True)

        fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(25, 40))

        # Figure displays one graph per industry group
        for industry, ax in zip(data[&#39;INDUSTRY&#39;].unique(), axes.flatten()):

            # Restricting the dataset to the industry group under consideration and excluding the US-US row
            restricted_df = data[
                np.logical_and(
                    data[&#39;INDUSTRY&#39;] == industry,
                    data[&#39;AFFILIATE_COUNTRY_CODE&#39;] != &#39;USA&#39;
                )
            ].copy()

            # Computing each partner country&#39;s share of US, industry-specific foreign unrelated-party revenues
            restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;] = (
                restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].astype(float) /
                restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].sum()
            )

            # Computing each partner country&#39;s share of GNI
            restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;] = (
                restricted_df[f&#39;GNI_{self.year}&#39;] / restricted_df[f&#39;GNI_{self.year}&#39;].sum()
            )

            # Computing the correlation between the two shares for the industry under consideration
            correlation = np.corrcoef(
                restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;],
                restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;]
            )[1, 0]

            # Distinguishing non-havens, tax havens and NAFTA members
            restricted_df[&#39;Category&#39;] = (
                restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin(self.tax_havens[&#39;CODE&#39;].unique()) * 1
                + restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin([&#39;CAN&#39;, &#39;MEX&#39;]) * 2
            )
            restricted_df[&#39;Category&#39;] = restricted_df[&#39;Category&#39;].map({0: &#39;Other&#39;, 1: &#39;Tax haven&#39;, 2: &#39;NAFTA member&#39;})

            restricted_df.rename(
                columns={
                    f&#39;SHARE_OF_GNI_{self.year}&#39;: f&#39;Share of total {self.year} GNI (%)&#39;,
                    &#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;: &#39;Share of total unrelated-party revenues (%)&#39;
                },
                inplace=True
            )

            # Building the graph with the indicative regression line and the scattered plot
            sns.regplot(
                x=f&#39;Share of total {self.year} GNI (%)&#39;,
                y=&#39;Share of total unrelated-party revenues (%)&#39;,
                data=restricted_df,
                ci=None,
                ax=ax
            )

            sns.scatterplot(
                x=f&#39;Share of total {self.year} GNI (%)&#39;,
                y=&#39;Share of total unrelated-party revenues (%)&#39;,
                data=restricted_df,
                hue=&#39;Category&#39;,
                palette={
                    &#39;Other&#39;: &#39;darkblue&#39;, &#39;Tax haven&#39;: &#39;darkred&#39;, &#39;NAFTA member&#39;: &#39;darkgreen&#39;
                },
                s=80,
                ax=ax
            )

            # Title indicating the industry being considered and the correlation between the share of foreign unrelated-
            # party revenues and the share of GNI
            ax.set_title(f&#39;{industry} - Correlation of {round(correlation, 2)}&#39;)

        plt.show()

        # Saving the figure into a PNG file if relevant
        if save_PNG:
            fig.savefig(
                os.path.join(
                    path_to_folder,
                    f&#39;industry_specific_charts_{self.year}.png&#39;
                )
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="destination_based_sales.per_industry.PerIndustryAnalyser.get_industry_overview_table"><code class="name flex">
<span>def <span class="ident">get_industry_overview_table</span></span>(<span>self, output_excel=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to output the industry overview table that shows, for each year in the sample period, the
distribution of US total unrelated-party revenues and foreign unrelated-party revenues between industries. It
corresponds to Table 3 in the PDF report of August 2021. The boolean argument, "output_excel", determines
whether to save the table in an Excel file (change the target file path before using this method with
"output_excel=True").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_industry_overview_table(self, output_excel=True):
    &#34;&#34;&#34;
    This method allows to output the industry overview table that shows, for each year in the sample period, the
    distribution of US total unrelated-party revenues and foreign unrelated-party revenues between industries. It
    corresponds to Table 3 in the PDF report of August 2021. The boolean argument, &#34;output_excel&#34;, determines
    whether to save the table in an Excel file (change the target file path before using this method with
    &#34;output_excel=True&#34;).
    &#34;&#34;&#34;
    final_output = {}

    for year in [2016, 2017, 2018]:
        # We instantiate an industry-specific analyser for each year
        analyser = PerIndustryAnalyser(year=year)

        # Loading the data
        data = analyser.load_clean_data(exclude_all_jurisdictions=False)

        # Focusing on industry totals and US-US rows
        data = data[data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;United States&#39;])].copy()

        # Eliminating irrelevant columns
        data.drop(
            columns=[
                &#39;AFFILIATE_COUNTRY_CODE&#39;, &#39;NB_REPORTING_MNEs&#39;,
                &#39;RELATED_PARTY_REVENUES&#39;, &#39;TOTAL_REVENUES&#39;
            ],
            inplace=True
        )

        # We pivot the DataFrame to show the revenues of each industry in all jurisdictions and in the US
        df = data.pivot(
            index=&#39;INDUSTRY&#39;,
            columns=&#39;AFFILIATE_COUNTRY_NAME&#39;,
            values=&#39;UNRELATED_PARTY_REVENUES&#39;
        ).reset_index()

        # Foreign unrelated-party revenues simply correspond to the total minus the US-US revenues
        df[&#39;FOREIGN_UPR&#39;] = df[&#39;All jurisdictions&#39;] - df[&#39;United States&#39;]

        # We move from absolute amounts to shares / a distribution
        df[&#39;Share of total unrelated-party revenues (%)&#39;] = (
            df[&#39;All jurisdictions&#39;] / df[&#39;All jurisdictions&#39;].sum() * 100
        )
        df[&#39;Share of foreign unrelated-party revenues (%)&#39;] = df[&#39;FOREIGN_UPR&#39;] / df[&#39;FOREIGN_UPR&#39;].sum() * 100

        df.drop(columns=[&#39;All jurisdictions&#39;, &#39;United States&#39;, &#39;FOREIGN_UPR&#39;], inplace=True)

        # Ranking industries based on decreasing importance in the distribution
        df.sort_values(by=&#39;Share of foreign unrelated-party revenues (%)&#39;, ascending=False, inplace=True)

        final_output[year] = df.copy()

    # Outputting the Excel file if relevant
    if output_excel:
        path_to_excel_file = &#39;/Users/Paul-Emmanuel/Desktop/industry_overview_table_PYTHON_OUTPUT.xlsx&#39;

        with pd.ExcelWriter(path_to_excel_file, engine=&#39;xlsxwriter&#39;) as writer:
            for key, value in final_output.items():
                value.to_excel(writer, sheet_name=str(key), index=False)

    return final_output.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.per_industry.PerIndustryAnalyser.load_clean_data"><code class="name flex">
<span>def <span class="ident">load_clean_data</span></span>(<span>self, exclude_all_jurisdictions=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This function allows to load and preprocess the industry-specific country-by-country data of the IRS.</p>
<p>It takes as argument a boolean, "exclude_all_jurisdictions", that determines whether or not to exclude the in-
dustry-level totals from the dataset. These are characterised by "All jurisdictions" as a partner country.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_clean_data(
    self,
    exclude_all_jurisdictions=True
):
    &#34;&#34;&#34;
    This function allows to load and preprocess the industry-specific country-by-country data of the IRS.

    It takes as argument a boolean, &#34;exclude_all_jurisdictions&#34;, that determines whether or not to exclude the in-
    dustry-level totals from the dataset. These are characterised by &#34;All jurisdictions&#34; as a partner country.
    &#34;&#34;&#34;

    # Loading the data from the corresponding Excel file
    path_to_industry_data = os.path.join(
        self.path_to_dir,
        &#39;data&#39;,
        str(self.year),
        f&#39;{self.year - 2000}it02cbc.xlsx&#39;
    )

    data = pd.read_excel(
        path_to_industry_data,
        engine=&#39;openpyxl&#39;
    )

    # Eliminating irrelevant columns and rows
    data = data[data.columns[:6]].copy()

    data.columns = [
        &#39;INDUSTRY&#39;,
        &#39;AFFILIATE_COUNTRY_NAME&#39;,
        &#39;NB_REPORTING_MNEs&#39;,
        &#39;UNRELATED_PARTY_REVENUES&#39;,
        &#39;RELATED_PARTY_REVENUES&#39;,
        &#39;TOTAL_REVENUES&#39;
    ]

    data = data[
        data.isnull().sum(axis=1) != len(data.columns)
    ].copy()
    data = data.iloc[4:-7].copy()

    data.reset_index(drop=True, inplace=True)

    # Adding the right industry name to each observation
    industry_indices = list(data[~data[&#39;INDUSTRY&#39;].isnull()].index)

    industries = {}

    for i in range(len(industry_indices)):

        if i &lt; len(industry_indices) - 1:
            restricted_df = data.loc[industry_indices[i]:industry_indices[i + 1] - 1].copy()

        else:
            restricted_df = data.loc[industry_indices[i]:].copy()

        industry = restricted_df[&#39;INDUSTRY&#39;].iloc[0]
        restricted_df[&#39;INDUSTRY&#39;] = industry
        industries[industry] = restricted_df.copy()

    data = industries[list(industries.keys())[0]].copy()

    for key, value in industries.items():
        if key == list(industries.keys())[0]:
            continue

        data = pd.concat([data, value], axis=0)

    # Eliminating irrelevant observations
    if exclude_all_jurisdictions:
        data = data[
            ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].isin([&#39;All jurisdictions&#39;, &#39;Stateless entities and other country&#39;])
        ].copy()

    else:
        data = data[
            data[&#39;AFFILIATE_COUNTRY_NAME&#39;] != &#39;Stateless entities and other country&#39;
        ].copy()

    data = data[
        ~data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
            lambda country_name: &#39;total&#39; in country_name.lower()
        )
    ].copy()

    data = data[
        data.drop(columns=[&#39;NB_REPORTING_MNEs&#39;]).applymap(
            lambda x: isinstance(x, str) and x == &#39;d&#39;
        ).sum(axis=1) == 0
    ].copy()

    # Renaming continental aggregates and a few specific partner jurisdictions
    data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
        (
            lambda country_name: f&#39;Other {country_name.split(&#34;,&#34;)[0].replace(&#34;&amp;&#34;, &#34;and&#34;)}&#39;
            if &#39;other&#39; in country_name.lower() else country_name
        )
    )

    data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
        lambda country_name: &#39;United Kingdom&#39; if &#39;United Kingdom&#39; in country_name else country_name
    )
    data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
        lambda country_name: &#39;Korea&#39; if country_name.startswith(&#39;Korea&#39;) else country_name
    )
    data[&#39;AFFILIATE_COUNTRY_NAME&#39;] = data[&#39;AFFILIATE_COUNTRY_NAME&#39;].map(
        lambda country_name: &#39;Congo&#39; if country_name.endswith(&#39;(Brazzaville)&#39;) else country_name
    )

    # Adding alpha-3 country codes
    geographies = pd.read_csv(self.path_to_geographies)

    data = data.merge(
        geographies[[&#39;NAME&#39;, &#39;CODE&#39;]],
        how=&#39;left&#39;,
        left_on=&#39;AFFILIATE_COUNTRY_NAME&#39;, right_on=&#39;NAME&#39;
    )

    data.drop(columns=[&#39;NAME&#39;], inplace=True)

    data[&#39;CODE&#39;] = data.apply(
        (
            lambda row: &#39;OASIAOCN&#39; if isinstance(row[&#39;CODE&#39;], float) and np.isnan(row[&#39;CODE&#39;])
            and row[&#39;AFFILIATE_COUNTRY_NAME&#39;] == &#39;Other Asia and Oceania&#39; else row[&#39;CODE&#39;]
        ),
        axis=1
    )

    data.rename(
        columns={
            &#39;CODE&#39;: &#39;AFFILIATE_COUNTRY_CODE&#39;
        },
        inplace=True
    )

    data.reset_index(drop=True, inplace=True)

    # Renaming industries for convenience
    data[&#39;INDUSTRY&#39;] = data[&#39;INDUSTRY&#39;].map(
        lambda industry: industry_names_mapping.get(industry, industry)
    )

    return data.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.per_industry.PerIndustryAnalyser.load_data_with_GNI"><code class="name flex">
<span>def <span class="ident">load_data_with_GNI</span></span>(<span>self, dropna=False, path_to_GNI_data='/Users/Paul-Emmanuel/Desktop/destination_based_sales/destination_based_sales/data/gross_national_income.csv')</span>
</code></dt>
<dd>
<div class="desc"><p>Building upon the previous method, "load_clean_data", this method allows to load and preprocess the industry-
specific country-by-country data while adding the Gross National Income (GNI) of each partner country, for the
corresponding year. It takes two arguments:</p>
<ul>
<li>a boolean, "dropna", indicating whether or not to exclude the partner countries for which we lack the GNI;</li>
<li>the string path to the file containing GNI data.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data_with_GNI(self, dropna=False, path_to_GNI_data=path_to_GNI_data):
    &#34;&#34;&#34;
    Building upon the previous method, &#34;load_clean_data&#34;, this method allows to load and preprocess the industry-
    specific country-by-country data while adding the Gross National Income (GNI) of each partner country, for the
    corresponding year. It takes two arguments:

    - a boolean, &#34;dropna&#34;, indicating whether or not to exclude the partner countries for which we lack the GNI;
    - the string path to the file containing GNI data.
    &#34;&#34;&#34;

    # Loading and cleaning industry-specific country-by-country data
    data = self.load_clean_data()

    # Loading and preprocessing Gross National Income (GNI) data
    gross_national_income = pd.read_csv(path_to_GNI_data, delimiter=&#39;;&#39;)
    gross_national_income = gross_national_income[[&#39;COUNTRY_CODE&#39;, f&#39;GNI_{self.year}&#39;]].copy()

    gross_national_income[f&#39;GNI_{self.year}&#39;] = gross_national_income[f&#39;GNI_{self.year}&#39;].map(
        lambda x: x.replace(&#39;,&#39;, &#39;.&#39;) if isinstance(x, str) else x
    ).astype(float)

    # Merging the two datasets on partner country codes
    data = data.merge(
        gross_national_income,
        how=&#39;left&#39;,
        left_on=&#39;AFFILIATE_COUNTRY_CODE&#39;, right_on=&#39;COUNTRY_CODE&#39;
    )

    data.drop(columns=[&#39;COUNTRY_CODE&#39;], inplace=True)

    if dropna:
        data.dropna(inplace=True)

    return data.copy()</code></pre>
</details>
</dd>
<dt id="destination_based_sales.per_industry.PerIndustryAnalyser.plot_industry_specific_charts"><code class="name flex">
<span>def <span class="ident">plot_industry_specific_charts</span></span>(<span>self, save_PNG=False, path_to_folder=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to output the graphs that show the relationship between partner jurisdictions’ share of US
multinational companies’ foreign unrelated-party revenues and their share of Gross National Income (GNI),
broken down by industry group. These correspond to Figure E.1 of the PDF report of August 2021.</p>
<p>The method takes two arguments used to save the output charts in a PNG file. This requires to set the boolean
"save_PNG" to True and to pass, in "path_to_folder", the string path to the target folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_industry_specific_charts(self, save_PNG=False, path_to_folder=None):
    &#34;&#34;&#34;
    This method allows to output the graphs that show the relationship between partner jurisdictions’ share of US
    multinational companies’ foreign unrelated-party revenues and their share of Gross National Income (GNI),
    broken down by industry group. These correspond to Figure E.1 of the PDF report of August 2021.

    The method takes two arguments used to save the output charts in a PNG file. This requires to set the boolean
    &#34;save_PNG&#34; to True and to pass, in &#34;path_to_folder&#34;, the string path to the target folder.
    &#34;&#34;&#34;

    # Setting Matplotlib parameters
    plt.rcParams.update({&#39;font.size&#39;: 18})

    if save_PNG and path_to_folder is None:
        raise Exception(&#39;To save the figure as a PNG, you must indicate the target folder as an argument.&#39;)

    # Loading cleaned data with GNI data (eliminating rows for which we have no GNI data)
    data = self.load_data_with_GNI(dropna=True)

    fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(25, 40))

    # Figure displays one graph per industry group
    for industry, ax in zip(data[&#39;INDUSTRY&#39;].unique(), axes.flatten()):

        # Restricting the dataset to the industry group under consideration and excluding the US-US row
        restricted_df = data[
            np.logical_and(
                data[&#39;INDUSTRY&#39;] == industry,
                data[&#39;AFFILIATE_COUNTRY_CODE&#39;] != &#39;USA&#39;
            )
        ].copy()

        # Computing each partner country&#39;s share of US, industry-specific foreign unrelated-party revenues
        restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;] = (
            restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].astype(float) /
            restricted_df[&#39;UNRELATED_PARTY_REVENUES&#39;].sum()
        )

        # Computing each partner country&#39;s share of GNI
        restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;] = (
            restricted_df[f&#39;GNI_{self.year}&#39;] / restricted_df[f&#39;GNI_{self.year}&#39;].sum()
        )

        # Computing the correlation between the two shares for the industry under consideration
        correlation = np.corrcoef(
            restricted_df[&#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;],
            restricted_df[f&#39;SHARE_OF_GNI_{self.year}&#39;]
        )[1, 0]

        # Distinguishing non-havens, tax havens and NAFTA members
        restricted_df[&#39;Category&#39;] = (
            restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin(self.tax_havens[&#39;CODE&#39;].unique()) * 1
            + restricted_df[&#39;AFFILIATE_COUNTRY_CODE&#39;].isin([&#39;CAN&#39;, &#39;MEX&#39;]) * 2
        )
        restricted_df[&#39;Category&#39;] = restricted_df[&#39;Category&#39;].map({0: &#39;Other&#39;, 1: &#39;Tax haven&#39;, 2: &#39;NAFTA member&#39;})

        restricted_df.rename(
            columns={
                f&#39;SHARE_OF_GNI_{self.year}&#39;: f&#39;Share of total {self.year} GNI (%)&#39;,
                &#39;SHARE_OF_UNRELATED_PARTY_REVENUES&#39;: &#39;Share of total unrelated-party revenues (%)&#39;
            },
            inplace=True
        )

        # Building the graph with the indicative regression line and the scattered plot
        sns.regplot(
            x=f&#39;Share of total {self.year} GNI (%)&#39;,
            y=&#39;Share of total unrelated-party revenues (%)&#39;,
            data=restricted_df,
            ci=None,
            ax=ax
        )

        sns.scatterplot(
            x=f&#39;Share of total {self.year} GNI (%)&#39;,
            y=&#39;Share of total unrelated-party revenues (%)&#39;,
            data=restricted_df,
            hue=&#39;Category&#39;,
            palette={
                &#39;Other&#39;: &#39;darkblue&#39;, &#39;Tax haven&#39;: &#39;darkred&#39;, &#39;NAFTA member&#39;: &#39;darkgreen&#39;
            },
            s=80,
            ax=ax
        )

        # Title indicating the industry being considered and the correlation between the share of foreign unrelated-
        # party revenues and the share of GNI
        ax.set_title(f&#39;{industry} - Correlation of {round(correlation, 2)}&#39;)

    plt.show()

    # Saving the figure into a PNG file if relevant
    if save_PNG:
        fig.savefig(
            os.path.join(
                path_to_folder,
                f&#39;industry_specific_charts_{self.year}.png&#39;
            )
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="destination_based_sales" href="index.html">destination_based_sales</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="destination_based_sales.per_industry.PerIndustryAnalyser" href="#destination_based_sales.per_industry.PerIndustryAnalyser">PerIndustryAnalyser</a></code></h4>
<ul class="">
<li><code><a title="destination_based_sales.per_industry.PerIndustryAnalyser.get_industry_overview_table" href="#destination_based_sales.per_industry.PerIndustryAnalyser.get_industry_overview_table">get_industry_overview_table</a></code></li>
<li><code><a title="destination_based_sales.per_industry.PerIndustryAnalyser.load_clean_data" href="#destination_based_sales.per_industry.PerIndustryAnalyser.load_clean_data">load_clean_data</a></code></li>
<li><code><a title="destination_based_sales.per_industry.PerIndustryAnalyser.load_data_with_GNI" href="#destination_based_sales.per_industry.PerIndustryAnalyser.load_data_with_GNI">load_data_with_GNI</a></code></li>
<li><code><a title="destination_based_sales.per_industry.PerIndustryAnalyser.plot_industry_specific_charts" href="#destination_based_sales.per_industry.PerIndustryAnalyser.plot_industry_specific_charts">plot_industry_specific_charts</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>